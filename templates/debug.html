<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Debug — {{ label }}</title>
<script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg:      #131316;
    --surface: #1a1a1f;
    --border:  #252530;
    --text:    #c8c8d8;
    --muted:   #55556a;
    --accent:  #5af0c4;
    --red:     #f05a7e;
    --yellow:  #f0c45a;
    --blue:    #5a9ef0;
    --orange:  #f0904a;
    --pass:    #5af0c4;
    --purple:  #a070f0;
  }
  html, body { height: 100%; overflow: hidden; background: var(--bg); color: var(--text);
    font-family: 'Space Mono', 'Menlo', monospace; font-size: 12px; }
  #layout { display: flex; height: 100vh; flex-direction: column; }
  #main   { display: flex; flex: 1; min-height: 0; }

  /* ── Mode switcher bar ── */
  #modebar {
    display: flex; align-items: center; gap: 0; padding: 0 14px;
    border-bottom: 1px solid var(--border); flex-shrink: 0; background: var(--bg);
  }
  #modebar h1 { font-size: 12px; color: #fff; margin-right: 18px; white-space: nowrap; letter-spacing: 0.04em; }
  .mode-btn {
    padding: 10px 16px; font-size: 10px; letter-spacing: 0.12em; text-transform: uppercase;
    cursor: pointer; color: var(--muted); border-bottom: 2px solid transparent;
    transition: all 0.15s; background: none; border-top: none; border-left: none; border-right: none;
    font-family: inherit; white-space: nowrap;
  }
  .mode-btn:hover  { color: var(--text); }
  .mode-btn.active { color: var(--accent); border-bottom-color: var(--accent); }
  .mode-btn.sd-btn.active  { color: var(--blue);   border-bottom-color: var(--blue); }
  .mode-btn.fvg-btn.active { color: var(--orange); border-bottom-color: var(--orange); }
  .mode-spacer { flex: 1; }
  #tag-mode { font-size: 9px; padding: 2px 8px; border-radius: 3px; border: 1px solid var(--border);
    color: var(--muted); white-space: nowrap; letter-spacing: 0.08em; text-transform: uppercase; }

  /* ── Timeframe switcher ── */
  #tf-bar { display: flex; gap: 3px; align-items: center; margin-right: 10px; }
  .tf-btn {
    padding: 3px 10px; font-size: 10px; letter-spacing: 0.08em; text-transform: uppercase;
    cursor: pointer; color: var(--muted); border: 1px solid var(--border); border-radius: 3px;
    background: var(--surface); font-family: inherit; transition: all 0.15s;
  }
  .tf-btn:hover  { border-color: var(--text); color: var(--text); }
  .tf-btn.active { border-color: var(--yellow); color: var(--yellow); background: rgba(240,196,90,0.06); }

  /* ── Left: chart ── */
  #left { flex: 1; display: flex; flex-direction: column; min-width: 0; }
  #topbar { display: flex; align-items: center; gap: 10px; padding: 6px 14px;
    border-bottom: 1px solid var(--border); flex-shrink: 0; flex-wrap: wrap; }
  .tag { font-size: 10px; padding: 2px 8px; border-radius: 3px; border: 1px solid var(--border);
    color: var(--muted); white-space: nowrap; }
  .tag.session { border-color: #5a9ef0; color: #5a9ef0; }
  .tag.replay  { border-color: var(--red); color: var(--red); }
  #btn-group { display: flex; gap: 6px; margin-left: auto; }
  .rbtn { background: var(--surface); border: 1px solid var(--border); border-radius: 3px;
    color: var(--muted); cursor: pointer; font-size: 11px; font-family: inherit;
    padding: 3px 10px; transition: all 0.15s; white-space: nowrap; }
  .rbtn:hover  { border-color: var(--accent); color: var(--accent); }
  .rbtn.active { border-color: var(--accent); color: var(--accent); background: rgba(90,240,196,0.06); }
  .rbtn:disabled { opacity: 0.3; cursor: default; pointer-events: none; }

  #chart-wrap { flex: 1; position: relative; min-height: 0; }
  #chart { width: 100%; height: 100%; }
  #cursor-line { position: absolute; top: 0; bottom: 0; width: 1px;
    background: rgba(240,90,126,0.6); pointer-events: none; display: none; z-index: 10; }

  #scrubber-row { display: flex; align-items: center; gap: 10px; padding: 6px 14px;
    border-top: 1px solid var(--border); flex-shrink: 0; background: var(--bg); }
  #scrubber { flex: 1; accent-color: var(--accent); cursor: pointer; height: 4px; }
  #scrub-label { font-size: 10px; color: var(--muted); min-width: 110px; text-align: right; white-space: nowrap; }
  #scrub-ts    { font-size: 10px; color: var(--muted); min-width: 120px; white-space: nowrap; }
  #replay-speed { width: 60px; font-size: 10px; background: var(--surface);
    border: 1px solid var(--border); border-radius: 3px; color: var(--text);
    padding: 2px 5px; font-family: inherit; }
  #replay-banner { display: none; padding: 4px 14px; font-size: 10px; color: var(--red);
    background: rgba(240,90,126,0.07); border-bottom: 1px solid rgba(240,90,126,0.2);
    letter-spacing: 0.06em; }

  /* ── Right panel ── */
  #right { width: 360px; flex-shrink: 0; display: flex; flex-direction: column;
    border-left: 1px solid var(--border); overflow: hidden; }

  /* ── Accum tabs ── */
  #right-tabs { display: flex; border-bottom: 1px solid var(--border); flex-shrink: 0; }
  .rtab { flex: 1; padding: 8px 4px; text-align: center; font-size: 10px; letter-spacing: 0.08em;
    text-transform: uppercase; cursor: pointer; color: var(--muted); border-bottom: 2px solid transparent;
    transition: all 0.15s; }
  .rtab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .rtab-panel { display: none; flex: 1; overflow-y: auto; padding: 10px; height: 100%; }
  .rtab-panel.active { display: block; }

  /* ── Stat cards ── */
  .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 12px; }
  .stat-card { background: var(--surface); border: 1px solid var(--border); border-radius: 4px; padding: 8px 10px; }
  .stat-label { font-size: 9px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 3px; }
  .stat-val { font-size: 18px; font-weight: 700; color: #fff; }
  .stat-val.green  { color: var(--pass); }
  .stat-val.red    { color: var(--red); }
  .stat-val.yellow { color: var(--yellow); }
  .stat-val.sm     { font-size: 14px; }

  /* ── Reject bars ── */
  .reject-list { margin-top: 10px; }
  .reject-row { padding: 5px 8px; border-radius: 3px; margin-bottom: 3px;
    background: var(--surface); border-left: 3px solid; }
  .reject-row.range   { border-color: var(--yellow); }
  .reject-row.slope   { border-color: var(--blue); }
  .reject-row.adx     { border-color: var(--red); }
  .reject-row.chop    { border-color: #a070f0; }
  .reject-row.v_shape { border-color: var(--muted); }
  .reject-label { font-size: 10px; color: var(--text); }
  .reject-count { font-size: 12px; font-weight: 700; color: #fff; }
  .reject-bar      { height: 3px; background: var(--border); border-radius: 2px; margin-top: 4px; }
  .reject-bar-fill { height: 100%; border-radius: 2px; }

  /* ── Window list ── */
  #window-search { width: 100%; background: var(--surface); border: 1px solid var(--border);
    border-radius: 3px; color: var(--text); padding: 5px 8px; font-family: inherit;
    font-size: 11px; margin-bottom: 8px; }
  #window-search:focus { outline: none; border-color: var(--accent); }
  .win-row { display: flex; align-items: center; gap: 6px; padding: 5px 8px; border-radius: 3px;
    margin-bottom: 2px; cursor: pointer; border: 1px solid transparent; transition: all 0.1s; }
  .win-row:hover    { border-color: var(--border); background: var(--surface); }
  .win-row.selected { border-color: var(--accent); background: rgba(90,240,196,0.04); }
  .win-row.pass-row { border-left: 3px solid var(--pass); }
  .win-row.fail-row { border-left: 3px solid #333; }
  .win-num    { width: 28px; color: var(--muted); font-size: 10px; flex-shrink: 0; }
  .win-status { font-size: 10px; flex: 1; }
  .win-status.pass { color: var(--pass); }
  .win-status.fail { color: var(--muted); }
  .win-chop  { font-size: 10px; color: var(--muted); width: 42px; text-align: right; flex-shrink: 0; }
  .win-extra { font-size: 9px; color: var(--muted); width: 54px; text-align: right; flex-shrink: 0; }

  /* ── Detail panel ── */
  #detail-title { font-size: 11px; color: var(--accent); margin-bottom: 10px; padding-bottom: 6px;
    border-bottom: 1px solid var(--border); }
  .detail-row { display: flex; justify-content: space-between; padding: 4px 0;
    border-bottom: 1px solid rgba(255,255,255,0.04); }
  .detail-key { color: var(--muted); font-size: 10px; }
  .detail-val { font-size: 10px; font-weight: 600; }
  .detail-val.pass    { color: var(--pass); }
  .detail-val.fail    { color: var(--red); }
  .detail-val.neutral { color: var(--text); }
  .bar-track { height: 3px; background: var(--border); border-radius: 2px; flex: 1; margin-left: 10px; }
  .bar-fill  { height: 100%; border-radius: 2px; max-width: 100%; }

  /* ── S&D panel ── */
  .sd-section-title { font-size: 9px; text-transform: uppercase; letter-spacing: 0.14em;
    color: var(--muted); margin: 12px 0 6px; padding-bottom: 4px; border-bottom: 1px solid var(--border); }
  .bias-block { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px; }
  .bias-cell { background: var(--surface); border: 1px solid var(--border); border-radius: 3px; padding: 6px 8px; }
  .bias-cell-label { font-size: 9px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.1em; }
  .bias-cell-val { font-size: 13px; font-weight: 700; margin-top: 2px; }
  .bias-cell-val.bullish   { color: var(--pass); }
  .bias-cell-val.bearish   { color: var(--red); }
  .bias-cell-val.misaligned{ color: var(--muted); }

  .zone-row { padding: 7px 10px; border-radius: 3px; margin-bottom: 4px; cursor: pointer;
    border: 1px solid var(--border); background: var(--surface); transition: all 0.1s; }
  .zone-row:hover { border-color: var(--blue); }
  .zone-row.selected-zone { border-color: var(--yellow) !important; background: rgba(240,196,90,0.05); }
  .zone-row.demand-row   { border-left: 3px solid var(--blue); }
  .zone-row.supply-row   { border-left: 3px solid var(--red); }
  .zone-row.rejected-row { border-left: 3px solid #2a2a3a; }
  .zone-top-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
  .zone-type-badge { font-size: 9px; letter-spacing: 0.1em; text-transform: uppercase; padding: 1px 6px;
    border-radius: 2px; border: 1px solid; }
  .zone-type-badge.demand { border-color: rgba(90,158,240,0.5); color: var(--blue); }
  .zone-type-badge.supply { border-color: rgba(240,90,126,0.5); color: var(--red); }
  .zone-type-badge.reject { border-color: #333; color: var(--muted); }
  .zone-time { font-size: 9px; color: var(--muted); }
  .zone-range { font-size: 11px; color: var(--text); font-weight: 600; }
  .zone-reject-reason { font-size: 9px; color: var(--muted); margin-top: 2px; font-style: italic; }

  /* ── FVG panel ── */
  .fvg-row { padding: 7px 10px; border-radius: 3px; margin-bottom: 4px; cursor: pointer;
    border: 1px solid var(--border); background: var(--surface); transition: all 0.1s; }
  .fvg-row:hover { border-color: var(--orange); }
  .fvg-row.selected-fvg  { border-color: var(--yellow) !important; background: rgba(240,196,90,0.05); }
  .fvg-row.pass-fvg { border-left: 3px solid var(--orange); }
  .fvg-row.fail-fvg { border-left: 3px solid #2a2a3a; }
  .fvg-top-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
  .fvg-badge { font-size: 9px; letter-spacing: 0.1em; text-transform: uppercase; padding: 1px 6px;
    border-radius: 2px; border: 1px solid; }
  .fvg-badge.bullish { border-color: rgba(90,158,240,0.5); color: var(--blue); }
  .fvg-badge.bearish { border-color: rgba(240,90,126,0.5); color: var(--red); }
  .fvg-badge.no-fvg  { border-color: #333; color: var(--muted); }
  .fvg-detail-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-top: 6px; }
  .fvg-candle-cell { background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 5px 6px; }
  .fvg-candle-label { font-size: 8px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 2px; }
  .fvg-candle-hl { font-size: 10px; color: var(--text); }
  .fvg-gap-line { margin: 5px 0; padding: 4px 8px; font-size: 10px; border-radius: 2px; border: 1px dashed; }
  .fvg-gap-line.gap-exists  { border-color: var(--orange); color: var(--orange); }
  .fvg-gap-line.gap-missing { border-color: #333; color: var(--muted); }

  /* ── Shared helpers ── */
  .panel-empty { padding: 20px 10px; text-align: center; color: var(--muted); font-size: 11px; }
  .panel-scroll { flex: 1; overflow-y: auto; padding: 10px; }
  .section-header { font-size: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.12em;
    margin-bottom: 8px; padding-bottom: 5px; border-bottom: 1px solid var(--border);
    display: flex; justify-content: space-between; align-items: center; }
  .section-count { font-size: 10px; color: var(--text); font-weight: 700; }
  .info-bar { font-size: 9px; color: var(--muted); padding: 4px 6px; background: var(--surface);
    border: 1px solid var(--border); border-radius: 3px; margin-bottom: 8px; }
  .info-bar strong { color: var(--orange); }

  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
</style>
</head>
<body>
<div id="layout">

  <!-- ── Mode + TF switcher bar ── -->
  <div id="modebar">
    <h1>⚙ {{ label }}</h1>
    <button class="mode-btn active"  id="mode-accum" onclick="switchMode('accum')">① Accumulation</button>
    <button class="mode-btn sd-btn"  id="mode-sd"    onclick="switchMode('sd')">② Supply &amp; Demand</button>
    <button class="mode-btn fvg-btn" id="mode-fvg"   onclick="switchMode('fvg')">③ Fair Value Gap</button>
    <span class="mode-spacer"></span>
    <div id="tf-bar">
      <button class="tf-btn active" data-tf="1m"  onclick="switchTF('1m')">1m</button>
      <button class="tf-btn"        data-tf="15m" onclick="switchTF('15m')">15m</button>
      <button class="tf-btn"        data-tf="30m" onclick="switchTF('30m')">30m</button>
    </div>
    <span id="tag-mode">accumulation</span>
  </div>

  <div id="main">
    <!-- ── LEFT: Chart ── -->
    <div id="left">
      <div id="topbar">
        <span class="tag session" id="tag-session">loading…</span>
        <span class="tag" id="tag-info">…</span>
        <span class="tag replay" id="tag-replay" style="display:none">⏮ REPLAY</span>
        <div id="btn-group">
          <button class="rbtn active" id="btn-live">Live</button>
          <button class="rbtn" id="btn-replay">⏮ Replay</button>
          <button class="rbtn" id="btn-prev" disabled>◀</button>
          <button class="rbtn" id="btn-play" disabled>▶</button>
          <button class="rbtn" id="btn-next" disabled>▶|</button>
          <select id="replay-speed" disabled>
            <option value="600">0.5×</option>
            <option value="300" selected>1×</option>
            <option value="150">2×</option>
            <option value="60">4×</option>
          </select>
          <button class="rbtn" id="btn-refresh" onclick="refreshCurrentMode()">⟳ Refresh</button>
        </div>
      </div>
      <div id="replay-banner">⏮ REPLAY MODE — click any candle or drag the scrubber to seek</div>
      <div id="chart-wrap">
        <div id="chart"></div>
        <div id="cursor-line"></div>
      </div>
      <div id="scrubber-row">
        <input type="range" id="scrubber" min="0" value="0" step="1" disabled />
        <span id="scrub-ts">—</span>
        <span id="scrub-label">candle — / —</span>
        <button class="rbtn" id="btn-analyze" disabled>▶ Run Detector</button>
      </div>
    </div>

    <!-- ── RIGHT: Panel (one per mode) ── -->
    <div id="right">

      <!-- ① ACCUMULATION -->
      <div id="panel-accum" style="display:flex;flex-direction:column;height:100%;overflow:hidden;">
        <div id="right-tabs">
          <div class="rtab active" data-tab="summary">Summary</div>
          <div class="rtab" data-tab="windows">Windows</div>
          <div class="rtab" data-tab="detail">Detail</div>
        </div>
        <div id="tab-summary" class="rtab-panel active">
          <div class="stat-grid" id="stat-grid"></div>
          <div class="reject-list" id="reject-list"></div>
        </div>
        <div id="tab-windows" class="rtab-panel">
          <input id="window-search" placeholder="Filter: pass / fail / range / slope / adx…" />
          <div id="window-list"></div>
        </div>
        <div id="tab-detail" class="rtab-panel">
          <div id="detail-title">← click a window row</div>
          <div id="detail-body"></div>
        </div>
      </div>

      <!-- ② SUPPLY & DEMAND -->
      <div id="panel-sd" style="display:none;flex-direction:column;height:100%;overflow:hidden;">
        <div class="panel-scroll">
          <div id="sd-loading" class="panel-empty">Click ⟳ Refresh to load S&amp;D analysis</div>
          <div id="sd-content" style="display:none">
            <div class="sd-section-title">Bias (Daily + Weekly)</div>
            <div class="bias-block" id="sd-bias-block"></div>
            <div id="sd-bias-verdict"></div>
            <div class="sd-section-title" style="margin-top:14px">Zone Candidates</div>
            <div id="sd-info-bar" class="info-bar" style="display:none"></div>
            <div id="sd-zone-list"></div>
          </div>
        </div>
      </div>

      <!-- ③ FAIR VALUE GAP -->
      <div id="panel-fvg" style="display:none;flex-direction:column;height:100%;overflow:hidden;">
        <div class="panel-scroll">
          <div id="fvg-loading" class="panel-empty">Click ⟳ Refresh to run FVG analysis</div>
          <div id="fvg-content" style="display:none">
            <div class="sd-section-title">Fair Value Gap Scanner</div>
            <div id="fvg-info-bar" class="info-bar" style="display:none"></div>
            <div id="fvg-stats" style="margin-bottom:10px"></div>
            <div id="fvg-list"></div>
          </div>
        </div>
      </div>

    </div><!-- #right -->
  </div><!-- #main -->
</div><!-- #layout -->

<script>
// ── Constants injected by Flask ───────────────────────────────────────────────
const PAIR_ID  = {{ pair_id | tojson }};
const TIMEZONE = {{ timezone | tojson }};

// ── Timezone helper ───────────────────────────────────────────────────────────
function getTzOffset(tz) {
  try {
    const now = new Date();
    return (new Date(now.toLocaleString('en-US',{timeZone:tz})) - new Date(now.toLocaleString('en-US',{timeZone:'UTC'}))) / 1000;
  } catch(e) { return 0; }
}
const TZ_OFFSET = getTzOffset(TIMEZONE);
function shiftTime(ts) { return ts + TZ_OFFSET; }
function fmtTime(ts)   { return new Date((ts + TZ_OFFSET)*1000).toISOString().replace('T',' ').slice(0,16); }
function fmtPrice(v, decimals) {
  if (v == null) return '—';
  const d = decimals != null ? decimals : (v > 100 ? 2 : 5);
  return v.toFixed(d);
}

// ── App State ─────────────────────────────────────────────────────────────────
let currentMode = 'accum';
let currentTF   = '1m';
let liveData    = null;
let replayData  = null;
let replayMode  = false;
let replayIdx   = 0;
let replayTimer = null;
let selectedWindow = null;
let overlaySeriesList = [];
let sdData  = null;
let fvgData = null;

// ── Chart setup ───────────────────────────────────────────────────────────────
const chartContainer = document.getElementById('chart');
const chart = LightweightCharts.createChart(chartContainer, {
  layout:    { background: { color: '#131316' }, textColor: '#c8c8d8' },
  grid:      { vertLines: { visible: false }, horzLines: { visible: false } },
  timeScale: { timeVisible: true, secondsVisible: false, borderColor: '#252530' },
  crosshair: { mode: 1 },
});
const candleSeries = chart.addCandlestickSeries({
  upColor:'#d4d0d0', downColor:'#068c76',
  wickUpColor:'#d4d0d0', wickDownColor:'#068c76',
  borderVisible: false,
});
window.addEventListener('resize', () => chart.applyOptions({
  width: chartContainer.clientWidth, height: chartContainer.clientHeight,
}));
chart.subscribeClick(param => {
  if (!param.time) return;

  if (replayMode && liveData && currentMode === 'accum') {
    // Accumulation replay: click candle to seek
    const idx = liveData.candles.findIndex(c => c.time === param.time);
    if (idx >= 0) seekTo(idx + 1);
    return;
  }

  if (currentMode === 'sd' && sdData?.candidates) {
    // SD mode: click a candle → find the zone whose start timestamp is closest
    // to the clicked time and select it in the panel.
    const clickedTs = param.time - TZ_OFFSET; // undo the shiftTime applied to chart
    const candidates = sdData.candidates;
    let bestIdx  = -1;
    let bestIsActive = false;
    let bestDist = Infinity;

    const active   = candidates.filter(c => c.is_active);
    const rejected = candidates.filter(c => !c.is_active);

    active.forEach((z, i) => {
      const dist = Math.abs((z.start || 0) - clickedTs);
      if (dist < bestDist) { bestDist = dist; bestIdx = i; bestIsActive = true; }
    });
    rejected.forEach((z, i) => {
      const dist = Math.abs((z.start || 0) - clickedTs);
      if (dist < bestDist) { bestDist = dist; bestIdx = i + 1000; bestIsActive = false; }
    });

    // Only select if click was within ~5 candle-widths of a zone start
    const src = sdData.candles;
    const intervalSecs = src?.length > 1 ? src[1].time - src[0].time : 1800;
    if (bestIdx >= 0 && bestDist < intervalSecs * 5) {
      selectZone(bestIdx, bestIsActive);
    }
    return;
  }

  if (currentMode === 'fvg' && fvgData?.candidates) {
    // FVG mode: click a candle → find the FVG whose impulse candle is closest
    const clickedTs = param.time - TZ_OFFSET;
    const withFvg    = fvgData.candidates.filter(c => c.has_fvg);
    const withoutFvg = fvgData.candidates.filter(c => !c.has_fvg);
    let bestIdx  = -1;
    let bestDist = Infinity;

    withFvg.forEach((c, i) => {
      const dist = Math.abs((c.candle_n?.time || 0) - clickedTs);
      if (dist < bestDist) { bestDist = dist; bestIdx = i; }
    });
    withoutFvg.forEach((c, i) => {
      const dist = Math.abs((c.candle_n?.time || 0) - clickedTs);
      if (dist < bestDist) { bestDist = dist; bestIdx = i + 1000; }
    });

    const src = fvgData.candles;
    const intervalSecs = src?.length > 1 ? src[1].time - src[0].time : 60;
    if (bestIdx >= 0 && bestDist < intervalSecs * 5) {
      selectFvg(bestIdx);
    }
    return;
  }
});

// ── Overlay helpers ───────────────────────────────────────────────────────────
function clearOverlays() {
  overlaySeriesList.forEach(s => { try { chart.removeSeries(s); } catch(e){} });
  overlaySeriesList = [];
}

function drawBox(startTs, endTs, top, bottom, lineColor, fillAlpha) {
  // Draws a price zone rectangle using:
  //   - top border:  horizontal LineSeries
  //   - bottom border: horizontal LineSeries
  //   - fill:        BaselineSeries (translucent band)
  //   - left/right vertical edges: dashed LineSeries spanning the full chart
  //     height, visually clipped by the fact they sit exactly at the box edges.
  //
  // NOTE: LightweightCharts has no rectangle primitive. Vertical LineSeries are
  // impossible (same-timestamp points throw, duplicate times not allowed). We skip
  // the vertical walls and use the horizontal borders + fill only, which is the
  // standard TradingView zone style. The fill makes the box shape visually clear.

  if (top == null || bottom == null || top === bottom) return;

  const toRgba = (color, alpha) => {
    const m = color.match(/rgba?\((\d+)[,\s]+(\d+)[,\s]+(\d+)/);
    return m ? 'rgba(' + m[1] + ',' + m[2] + ',' + m[3] + ',' + alpha + ')' : color;
  };

  const s = shiftTime(startTs), e = shiftTime(endTs);

  const lOpts = {
    lineWidth: 1, lineStyle: 0,
    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
  };

  // Top horizontal border
  const tl = chart.addLineSeries({ ...lOpts, color: lineColor });
  tl.setData([{ time: s, value: top }, { time: e, value: top }]);

  // Bottom horizontal border
  const bl = chart.addLineSeries({ ...lOpts, color: lineColor });
  bl.setData([{ time: s, value: bottom }, { time: e, value: bottom }]);

  // Translucent fill
  const fl = chart.addBaselineSeries({
    baseValue: { type: 'price', price: bottom },
    topFillColor1: toRgba(lineColor, fillAlpha), topFillColor2: toRgba(lineColor, fillAlpha),
    topLineColor:     'rgba(0,0,0,0)',
    bottomFillColor1: 'rgba(0,0,0,0)', bottomFillColor2: 'rgba(0,0,0,0)',
    bottomLineColor:  'rgba(0,0,0,0)',
    lineWidth: 0,
    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
  });
  fl.setData([{ time: s, value: top }, { time: e, value: top }]);

  overlaySeriesList.push(tl, bl, fl);
}

function drawVLine(ts, color) {
  // Derive visible price range from whichever dataset is currently on the chart
  const activeCandleData = (currentMode === 'fvg' && fvgData?.candles)
    ? fvgData.candles
    : (currentMode === 'sd' && sdData?.candles)
    ? sdData.candles
    : liveData?.candles;
  if (!activeCandleData?.length) return;
  const prices = activeCandleData.flatMap(c => [c.high, c.low]);
  const minP = Math.min(...prices) * 0.999;
  const maxP = Math.max(...prices) * 1.001;
  const s = chart.addLineSeries({ color, lineWidth: 1, lineStyle: 2,
    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false });
  s.setData([{ time: shiftTime(ts), value: minP }, { time: shiftTime(ts), value: maxP }]);
  overlaySeriesList.push(s);
}

function renderChart(candles) {
  candleSeries.setData(candles.map(c => ({...c, time: shiftTime(c.time)})));
  chart.timeScale().fitContent();
}

// ═════════════════════════════════════════════════════════════════════════════
// MODE + TF SWITCHING
// ═════════════════════════════════════════════════════════════════════════════

function switchMode(mode) {
  currentMode = mode;
  ['accum','sd','fvg'].forEach(m => {
    document.getElementById('mode-' + m).classList.toggle('active', m === mode);
    document.getElementById('panel-' + m).style.display = m === mode ? 'flex' : 'none';
  });
  const labels = { accum: 'accumulation', sd: 'supply & demand', fvg: 'fair value gap' };
  document.getElementById('tag-mode').textContent = labels[mode];
  clearOverlays();

  // Replay controls only for accumulation
  const replayIds = ['btn-replay','btn-prev','btn-play','btn-next','replay-speed','btn-analyze'];
  replayIds.forEach(id => {
    document.getElementById(id).style.display = mode === 'accum' ? '' : 'none';
  });

  if (mode === 'accum') {
    if (replayMode) exitReplayMode();
    if (liveData) { renderChart(liveData.candles); updateTopbarAccum(liveData, false); }
    else loadLiveData();
  } else if (mode === 'sd') {
    document.getElementById('tag-session').textContent = 'S/D MODE';
    document.getElementById('tag-info').textContent = currentTF + ' · supply & demand';
    if (sdData) { if (sdData.candles?.length) renderChart(sdData.candles); renderSD(sdData); }
    else showLoading('sd');
  } else if (mode === 'fvg') {
    document.getElementById('tag-session').textContent = 'FVG MODE';
    document.getElementById('tag-info').textContent = currentTF + ' · fair value gap';
    if (fvgData) { if (fvgData.candles?.length) renderChart(fvgData.candles); renderFVG(fvgData); }
    else showLoading('fvg');
  }
}

function switchTF(tf) {
  currentTF = tf;
  document.querySelectorAll('.tf-btn').forEach(b => b.classList.toggle('active', b.dataset.tf === tf));
  // Invalidate mode-specific cached data so next load fetches fresh
  sdData  = null;
  fvgData = null;
  // Also reload accumulation data since TF affects it
  liveData = null;
  refreshCurrentMode();
}

function refreshCurrentMode() {
  if (currentMode === 'accum') loadLiveData();
  else if (currentMode === 'sd') loadSD();
  else if (currentMode === 'fvg') loadFVG();
}

function showLoading(mode) {
  if (mode === 'sd') {
    document.getElementById('sd-loading').textContent = 'Click ⟳ Refresh to load S&D analysis';
    document.getElementById('sd-loading').style.display = '';
    document.getElementById('sd-content').style.display = 'none';
  } else if (mode === 'fvg') {
    document.getElementById('fvg-loading').textContent = 'Click ⟳ Refresh to run FVG analysis';
    document.getElementById('fvg-loading').style.display = '';
    document.getElementById('fvg-content').style.display = 'none';
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// ① ACCUMULATION
// ═════════════════════════════════════════════════════════════════════════════

function updateTopbarAccum(d, isReplay) {
  document.getElementById('tag-session').textContent =
    d.session ? d.session.replace('_',' ').toUpperCase() : 'OUT OF SESSION';
  document.getElementById('tag-info').textContent =
    currentTF + ' · ' + d.passed + ' / ' + d.windows_checked + ' passed';
  document.getElementById('tag-replay').style.display = isReplay ? '' : 'none';
}

async function loadLiveData() {
  if (replayMode) return;
  try {
    const res = await fetch('/debug/data?interval=' + currentTF);
    liveData = await res.json();
    renderChart(liveData.candles);
    renderSummary(liveData);
    renderWindowList(liveData.windows);
    if (currentMode === 'accum') updateTopbarAccum(liveData, false);
    const sc = document.getElementById('scrubber');
    sc.max   = liveData.candles.length - 1;
    sc.value = liveData.candles.length - 1;
  } catch(e) {
    console.error('loadLiveData:', e);
  }
}

let replayFetchCtrl = null;
async function fetchReplay(idx) {
  if (replayFetchCtrl) replayFetchCtrl.abort();
  replayFetchCtrl = new AbortController();
  const btn = document.getElementById('btn-analyze');
  btn.textContent = '⏳…'; btn.disabled = true;
  try {
    const res = await fetch('/debug/replay?idx=' + idx, { signal: replayFetchCtrl.signal });
    const data = await res.json();
    if (data.error) return;
    replayData = data;
    renderSummary(replayData);
    renderWindowList(replayData.windows || []);
    updateTopbarAccum(replayData, true);
    if (selectedWindow == null && replayData.best_zone) drawWindowOverlay(replayData.best_zone, replayData);
    else if (selectedWindow != null) {
      const w = (replayData.windows || []).find(x => x.window === selectedWindow);
      drawWindowOverlay(w || null, replayData);
    } else drawWindowOverlay(null, replayData);
  } catch(e) {
    if (e.name !== 'AbortError') console.error('Replay fetch:', e);
  } finally { btn.textContent = '▶ Run Detector'; btn.disabled = false; }
}

async function seekTo(idx) {
  const total = liveData.candles.length;
  idx = Math.max(18, Math.min(idx, total));
  replayIdx = idx;
  const slice = liveData.candles.slice(0, idx);
  candleSeries.setData(slice.map(c => ({...c, time: shiftTime(c.time)})));
  chart.timeScale().fitContent();
  const sc = document.getElementById('scrubber');
  sc.value = idx - 1;
  const last = slice[slice.length - 1];
  document.getElementById('scrub-ts').textContent =
    last ? fmtTime(last.time) + ' ' + TIMEZONE : '—';
  document.getElementById('scrub-label').textContent = 'candle ' + idx + ' / ' + total;
}

function renderSummary(d) {
  const total    = d.windows_checked || 1;
  const passRate = Math.round((d.passed / total) * 100);
  const stats = [
    { label:'Candles',   val: d.idx || d.candles?.length || '—', cls:'neutral' },
    { label:'Windows',   val: d.windows_checked,                  cls:'neutral' },
    { label:'Passed',    val: d.passed,                           cls: d.passed > 0 ? 'green' : 'red' },
    { label:'Pass Rate', val: passRate + '%',                     cls: passRate > 10 ? 'green' : 'yellow' },
  ];
  document.getElementById('stat-grid').innerHTML = stats.map(s =>
    '<div class="stat-card"><div class="stat-label">' + s.label + '</div>' +
    '<div class="stat-val ' + s.cls + '">' + s.val + '</div></div>'
  ).join('');

  // ── Breakout candle block ──────────────────────────────────────────────────
  const bo = d.breakout_candle;
  const cf = d.confirm_candle;
  const ac = d.accum_last_candle;
  const bHtml = bo ? (() => {
    const isBull = bo.close > bo.open;
    const bCol   = isBull ? 'var(--pass)' : 'var(--red)';
    const bDir   = isBull ? '▲ BULL' : '▼ BEAR';

    // FVG check summary across all passing windows
    const passingWindows = (d.windows || []).filter(w => w.pass);
    const fvgPassing = passingWindows.filter(w => w.fvg_valid);
    const fvgStatus  = passingWindows.length === 0 ? 'no passing windows'
                     : fvgPassing.length > 0 ? fvgPassing.length + ' / ' + passingWindows.length + ' windows confirmed FVG'
                     : '✗ 0 / ' + passingWindows.length + ' windows — no FVG';
    const fvgCol = fvgPassing.length > 0 ? 'var(--pass)' : 'var(--red)';

    return '<div style="margin:10px 0;padding:8px 10px;background:var(--surface);border:1px solid var(--border);border-radius:4px">' +
      '<div style="font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em;margin-bottom:6px">Breakout Candle (df[-3])</div>' +
      '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;margin-bottom:6px">' +
        '<div style="background:var(--bg);border:1px solid #333;border-radius:3px;padding:5px 6px">' +
          '<div style="font-size:8px;color:var(--muted);margin-bottom:2px">N-1 (accum last)</div>' +
          '<div style="font-size:10px">H ' + (ac ? fmtPrice(ac.high) : '—') + '</div>' +
          '<div style="font-size:10px">L ' + (ac ? fmtPrice(ac.low)  : '—') + '</div>' +
        '</div>' +
        '<div style="background:var(--bg);border:1px solid ' + bCol + ';border-radius:3px;padding:5px 6px">' +
          '<div style="font-size:8px;color:var(--muted);margin-bottom:2px">N breakout</div>' +
          '<div style="font-size:10px;color:' + bCol + ';font-weight:700">' + bDir + '</div>' +
          '<div style="font-size:10px">O ' + fmtPrice(bo.open)  + '</div>' +
          '<div style="font-size:10px">C ' + fmtPrice(bo.close) + '</div>' +
          '<div style="font-size:10px">H ' + fmtPrice(bo.high)  + ' L ' + fmtPrice(bo.low) + '</div>' +
        '</div>' +
        '<div style="background:var(--bg);border:1px solid #333;border-radius:3px;padding:5px 6px">' +
          '<div style="font-size:8px;color:var(--muted);margin-bottom:2px">N+1 confirm (df[-2])</div>' +
          '<div style="font-size:10px">H ' + (cf ? fmtPrice(cf.high) : '—') + '</div>' +
          '<div style="font-size:10px">L ' + (cf ? fmtPrice(cf.low)  : '—') + '</div>' +
        '</div>' +
      '</div>' +
      '<div style="font-size:10px;color:' + fvgCol + '">' + fvgStatus + '</div>' +
    '</div>';
  })() : '';

  document.getElementById('reject-list').innerHTML =
    bHtml +
    '<div style="font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em;margin-bottom:6px;margin-top:10px">Rejection Reasons</div>' +
    (() => {
      const reasons  = d.rejection_summary || {};
      const sorted   = Object.entries(reasons).sort((a,b) => b[1]-a[1]);
      const maxCnt   = sorted.length ? sorted[0][1] : 1;
      const colorMap = { range:'#f0c45a', slope:'#5a9ef0', adx:'#f05a7e', chop:'#a070f0', v_shape:'#666' };
      return sorted.map(([key, cnt]) =>
        '<div class="reject-row ' + key + '">' +
          '<div style="display:flex;justify-content:space-between">' +
            '<span class="reject-label">' + key + '</span>' +
            '<span class="reject-count">' + cnt + '</span>' +
          '</div>' +
          '<div class="reject-bar"><div class="reject-bar-fill" style="width:' +
            Math.round(cnt/maxCnt*100) + '%;background:' + (colorMap[key]||'#666') + '"></div></div>' +
        '</div>'
      ).join('');
    })();
}

function getActiveWindows() {
  return replayMode && replayData ? replayData.windows : (liveData?.windows || []);
}

function renderWindowList(windows, filter) {
  filter = (filter || '').toLowerCase().trim();
  const filtered = windows.filter(w => {
    if (!filter) return true;
    if (filter === 'pass') return w.pass;
    if (filter === 'fail') return !w.pass;
    if (filter === 'fvg')  return w.fvg_valid;
    if (filter === 'breakout') return w.broke_out;
    if (filter === 'active')   return w.is_active;
    return (w.reject || '').toLowerCase().includes(filter);
  });
  document.getElementById('window-list').innerHTML = filtered.map(w => {
    const cls   = w.pass ? 'pass-row' : 'fail-row';
    const stCls = w.pass ? 'pass' : 'fail';
    const label = w.pass ? '✓ pass' : (w.reject||'?').split(' ')[0];

    // Breakout + FVG indicator
    let boTag = '';
    if (w.pass) {
      if (w.is_active) {
        boTag = '<span style="font-size:9px;color:var(--yellow);margin-left:4px">● active</span>';
      } else if (w.broke_out) {
        const fvgCol = w.fvg_valid ? 'var(--pass)' : 'var(--red)';
        const fvgTxt = w.fvg_valid ? '✓ FVG' : '✗ FVG';
        const dir    = w.broke_up ? '↑' : '↓';
        boTag = '<span style="font-size:9px;color:var(--muted);margin-left:4px">' + dir + ' broke</span>' +
                '<span style="font-size:9px;color:' + fvgCol + ';margin-left:4px">' + fvgTxt + '</span>';
      }
    }

    return '<div class="win-row ' + cls + '" data-win="' + w.window + '" onclick="selectWindow(' + w.window + ')">' +
      '<span class="win-num">' + w.window + '</span>' +
      '<span class="win-status ' + stCls + '">' + label + '</span>' +
      boTag +
      '<span class="win-chop" style="margin-left:auto">chop ' + w.chop + '</span>' +
      '</div>';
  }).join('');
  if (selectedWindow != null) {
    const el = document.querySelector('[data-win="' + selectedWindow + '"]');
    if (el) el.classList.add('selected');
  }
}

document.getElementById('window-search').addEventListener('input', e => {
  renderWindowList(getActiveWindows(), e.target.value);
});

function selectWindow(windowSize) {
  selectedWindow = windowSize;
  document.querySelectorAll('.win-row').forEach(el => el.classList.remove('selected'));
  const el = document.querySelector('[data-win="' + windowSize + '"]');
  if (el) el.classList.add('selected');
  const w = getActiveWindows().find(x => x.window === windowSize);
  if (!w) return;

  document.querySelectorAll('.rtab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.rtab-panel').forEach(p => p.classList.remove('active'));
  document.querySelector('[data-tab="detail"]').classList.add('active');
  document.getElementById('tab-detail').classList.add('active');

  // Title: show pass/fail reason + breakout/FVG outcome
  let titleSuffix = w.pass ? '✓ PASS' : '✗ ' + (w.reject||'').split(' ')[0].toUpperCase();
  if (w.pass && w.broke_out) titleSuffix += w.fvg_valid ? ' · ✓ FVG' : ' · ✗ NO FVG';
  else if (w.pass && w.is_active) titleSuffix += ' · ● ACTIVE';
  document.getElementById('detail-title').textContent = 'Window ' + windowSize + ' — ' + titleSuffix;

  // Accumulation quality rows
  const rows = [
    { key:'Range %',  val:(w.range_pct*100).toFixed(4)+'%', limit: w.range_limit ? (w.range_limit*100).toFixed(4)+'% max':'no limit', pass:!w.range_limit||w.range_pct<=w.range_limit, ratio:w.range_limit?w.range_pct/w.range_limit:0.5 },
    { key:'Slope',    val:w.slope,      limit:w.slope_limit,   pass:w.slope<w.slope_limit,                      ratio:w.slope/w.slope_limit },
    { key:'Chop',     val:w.chop,       limit:'≥0.44/0.36',    pass:w.chop>=0.36,                               ratio:w.chop/0.44 },
    { key:'ADX',      val:w.adx??'N/A', limit:'<'+w.adx_limit, pass:w.adx==null||w.adx<w.adx_limit,            ratio:w.adx!=null?w.adx/w.adx_limit:0 },
    { key:'ADX<10',   val:w.adx!=null?(w.adx<10?'✓ priority':'—'):'N/A', limit:'priority tier', pass:w.adx!=null&&w.adx<10, ratio:0 },
    { key:'Top',      val:w.top,        limit:'', pass:null, ratio:0 },
    { key:'Bottom',   val:w.bottom,     limit:'', pass:null, ratio:0 },
  ];

  const accumHtml = rows.map(r => {
    const cls    = r.pass===null?'neutral':r.pass?'pass':'fail';
    const barW   = Math.min(100, Math.round((r.ratio||0)*100));
    const barCol = r.pass===null?'#444':r.pass?'var(--pass)':'var(--red)';
    return '<div class="detail-row">' +
        '<span class="detail-key">' + r.key + '</span>' +
        '<div style="display:flex;align-items:center;flex:1;justify-content:flex-end;gap:6px">' +
          (r.ratio>0?'<div class="bar-track"><div class="bar-fill" style="width:'+barW+'%;background:'+barCol+'"></div></div>':'') +
          '<span class="detail-val ' + cls + '">' + r.val + '</span>' +
        '</div></div>' +
        (r.limit?'<div style="font-size:9px;color:var(--muted);padding:1px 0 5px 0;border-bottom:1px solid rgba(255,255,255,0.04)">limit: '+r.limit+'</div>':'');
  }).join('');

  // Breakout + FVG section (only for passing windows)
  let breakoutHtml = '';
  if (w.pass) {
    const activeData = replayMode ? replayData : liveData;
    const bo = activeData?.breakout_candle;
    const cf = activeData?.confirm_candle;
    const ac = activeData?.accum_last_candle;

    if (w.is_active) {
      breakoutHtml =
        '<div style="margin-top:10px;padding:8px 10px;background:rgba(240,196,90,0.05);border:1px solid rgba(240,196,90,0.2);border-radius:4px">' +
          '<div style="font-size:9px;color:var(--yellow);text-transform:uppercase;letter-spacing:.1em;margin-bottom:4px">● Zone Active</div>' +
          '<div style="font-size:10px;color:var(--muted)">Breakout candle (df[-3]) is still inside the box.</div>' +
        '</div>';
    } else if (w.broke_out) {
      const dir    = w.broke_up ? '↑ BULLISH BREAKOUT' : '↓ BEARISH BREAKOUT';
      const dirCol = w.broke_up ? 'var(--pass)' : 'var(--red)';
      const fvgCol = w.fvg_valid ? 'var(--pass)' : 'var(--red)';
      const fvgTxt = w.fvg_valid ? '✓ FVG CONFIRMED' : '✗ NO VALID FVG';
      const fvgSub = w.fvg_valid
        ? 'gap: ' + fmtPrice(w.fvg?.bottom) + ' → ' + fmtPrice(w.fvg?.top) + ' (' + w.fvg?.fvg_type + ')'
        : 'Breakout had no valid 3-candle fair value gap — window rejected';

      breakoutHtml =
        '<div style="margin-top:10px;padding:8px 10px;background:var(--surface);border:1px solid var(--border);border-radius:4px">' +
          '<div style="font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em;margin-bottom:6px">Breakout Candle (df[-3])</div>' +
          '<div style="font-size:10px;color:' + dirCol + ';font-weight:700;margin-bottom:6px">' + dir + '</div>' +
          // 3-candle mini grid
          '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:3px;margin-bottom:8px">' +
            '<div style="background:var(--bg);border:1px solid #333;border-radius:3px;padding:4px 5px">' +
              '<div style="font-size:8px;color:var(--muted);margin-bottom:2px">N-1 (last accum)</div>' +
              '<div style="font-size:9px">H ' + (ac ? fmtPrice(ac.high) : '—') + '</div>' +
              '<div style="font-size:9px">L ' + (ac ? fmtPrice(ac.low)  : '—') + '</div>' +
            '</div>' +
            '<div style="background:var(--bg);border:1px solid ' + dirCol + ';border-radius:3px;padding:4px 5px">' +
              '<div style="font-size:8px;color:var(--muted);margin-bottom:2px">N (breakout)</div>' +
              '<div style="font-size:9px">O ' + (bo ? fmtPrice(bo.open)  : '—') + '</div>' +
              '<div style="font-size:9px">C ' + (bo ? fmtPrice(bo.close) : '—') + '</div>' +
              '<div style="font-size:9px">H ' + (bo ? fmtPrice(bo.high)  : '—') + ' L ' + (bo ? fmtPrice(bo.low) : '—') + '</div>' +
            '</div>' +
            '<div style="background:var(--bg);border:1px solid #333;border-radius:3px;padding:4px 5px">' +
              '<div style="font-size:8px;color:var(--muted);margin-bottom:2px">N+1 (confirm)</div>' +
              '<div style="font-size:9px">H ' + (cf ? fmtPrice(cf.high) : '—') + '</div>' +
              '<div style="font-size:9px">L ' + (cf ? fmtPrice(cf.low)  : '—') + '</div>' +
            '</div>' +
          '</div>' +
          // FVG verdict
          '<div style="padding:5px 8px;border-radius:3px;border:1px solid ' + fvgCol + ';background:rgba(0,0,0,0.2)">' +
            '<div style="font-size:10px;color:' + fvgCol + ';font-weight:700;margin-bottom:2px">' + fvgTxt + '</div>' +
            '<div style="font-size:9px;color:var(--muted)">' + fvgSub + '</div>' +
          '</div>' +
        '</div>';
    }
  }

  document.getElementById('detail-body').innerHTML = accumHtml + breakoutHtml;

  // Use the data object that matches the current mode (live vs replay)
  const activeData = replayMode ? replayData : liveData;
  drawWindowOverlay(w, activeData);
}

function drawWindowOverlay(w, data) {
  clearOverlays();
  if (!w?.start_ts) return;

  // Accumulation box
  const col  = w.pass ? 'rgba(90,240,196,0.7)' : 'rgba(240,90,126,0.55)';
  const fill = w.pass ? 0.06 : 0.04;
  drawBox(w.start_ts, w.end_ts, w.top, w.bottom, col, fill);

  // Only show breakout overlay if this window actually broke out
  if (!w.broke_out || !data) return;

  const bo = data.breakout_candle;
  const cf = data.confirm_candle;
  const ac = data.accum_last_candle;
  if (!bo) return;

  // Detect candle interval in seconds from the candle series
  const src = data.candles;
  const intervalSecs = (src?.length > 1) ? (src[1].time - src[0].time) : 60;

  // Vertical markers for the 3 FVG candles
  if (ac) drawVLine(ac.time, 'rgba(240,196,90,0.25)');
  drawVLine(bo.time, 'rgba(240,196,90,0.7)');
  if (cf) drawVLine(cf.time, 'rgba(240,196,90,0.35)');

  // Breakout candle body highlight
  const bCol = bo.close > bo.open ? 'rgba(90,158,240,0.8)' : 'rgba(240,90,126,0.8)';
  drawBox(bo.time, bo.time + intervalSecs, bo.high, bo.low, bCol, 0.12);

  // FVG gap zone if confirmed on this window
  if (w.fvg?.top != null) {
    const gCol  = w.fvg.fvg_type === 'bullish' ? 'rgba(90,158,240,0.9)' : 'rgba(240,90,126,0.9)';
    const spanS = ac?.time  ?? (bo.time - intervalSecs);
    const spanE = cf?.time  ? (cf.time + intervalSecs) : (bo.time + intervalSecs * 2);
    drawBox(spanS, spanE, w.fvg.top, w.fvg.bottom, gCol, 0.30);
  }
}

// Replay
function enterReplayMode() {
  replayMode = true; selectedWindow = null;
  const total = liveData.candles.length;
  replayIdx = Math.max(22, Math.floor(total * 0.6));
  document.getElementById('btn-live').classList.remove('active');
  document.getElementById('btn-replay').classList.add('active');
  ['btn-prev','btn-play','btn-next'].forEach(id => document.getElementById(id).disabled = false);
  document.getElementById('replay-speed').disabled = false;
  document.getElementById('scrubber').disabled   = false;
  document.getElementById('btn-analyze').disabled = false;
  document.getElementById('scrubber').max = total - 1;
  document.getElementById('replay-banner').style.display = '';
  seekTo(replayIdx);
}

function exitReplayMode() {
  stopPlay(); replayMode = false; replayData = null; selectedWindow = null;
  document.getElementById('btn-live').classList.add('active');
  document.getElementById('btn-replay').classList.remove('active');
  ['btn-prev','btn-play','btn-next'].forEach(id => document.getElementById(id).disabled = true);
  document.getElementById('replay-speed').disabled = true;
  document.getElementById('scrubber').disabled     = true;
  document.getElementById('btn-analyze').disabled  = true;
  document.getElementById('replay-banner').style.display = 'none';
  document.getElementById('tag-replay').style.display    = 'none';
  clearOverlays();
  renderChart(liveData.candles);
  renderSummary(liveData);
  renderWindowList(liveData.windows);
  updateTopbarAccum(liveData, false);
  const sc = document.getElementById('scrubber');
  sc.value = liveData.candles.length - 1;
  document.getElementById('scrub-label').textContent = 'candle — / —';
  document.getElementById('scrub-ts').textContent    = '—';
}

function startPlay() {
  const speed = parseInt(document.getElementById('replay-speed').value);
  document.getElementById('btn-play').textContent = '⏸';
  replayTimer = setInterval(async () => {
    if (replayIdx >= liveData.candles.length) { stopPlay(); return; }
    replayIdx++;
    await seekTo(replayIdx);
  }, speed);
}
function stopPlay() {
  if (replayTimer) { clearInterval(replayTimer); replayTimer = null; }
  document.getElementById('btn-play').textContent = '▶';
}

document.getElementById('btn-live').addEventListener('click', exitReplayMode);
document.getElementById('btn-replay').addEventListener('click', () => { if(!replayMode) enterReplayMode(); });
document.getElementById('btn-play').addEventListener('click', () => { replayTimer ? stopPlay() : startPlay(); });
document.getElementById('btn-prev').addEventListener('click', () => { stopPlay(); seekTo(replayIdx-1); });
document.getElementById('btn-next').addEventListener('click', () => { stopPlay(); seekTo(replayIdx+1); });
document.getElementById('btn-analyze').addEventListener('click', () => { if(replayMode) fetchReplay(replayIdx); });
document.getElementById('scrubber').addEventListener('input', function() {
  if (!replayMode) return;
  stopPlay();
  const idx = parseInt(this.value) + 1;
  const slice = liveData.candles.slice(0, idx);
  candleSeries.setData(slice.map(c => ({...c, time: shiftTime(c.time)})));
  const last = slice[slice.length-1];
  document.getElementById('scrub-ts').textContent = last ? fmtTime(last.time) + ' ' + TIMEZONE : '—';
  document.getElementById('scrub-label').textContent = 'candle ' + idx + ' / ' + liveData.candles.length;
  replayIdx = idx;
  clearOverlays();
});
document.querySelectorAll('.rtab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.rtab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.rtab-panel').forEach(p => p.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
  });
});

// ═════════════════════════════════════════════════════════════════════════════
// ② SUPPLY & DEMAND
// ═════════════════════════════════════════════════════════════════════════════

async function loadSD() {
  document.getElementById('sd-loading').textContent = '⟳ Loading S&D analysis (' + currentTF + ')…';
  document.getElementById('sd-loading').style.display = '';
  document.getElementById('sd-content').style.display = 'none';
  try {
    const res = await fetch('/debug/sd?interval=' + currentTF);
    sdData = await res.json();
    if (sdData.error) {
      document.getElementById('sd-loading').textContent = '✗ Error: ' + sdData.error;
      return;
    }
    if (sdData.candles?.length) renderChart(sdData.candles);
    renderSD(sdData);
  } catch(e) {
    document.getElementById('sd-loading').textContent = '✗ Fetch failed: ' + e.message;
  }
}

function renderSD(data) {
  document.getElementById('sd-loading').style.display  = 'none';
  document.getElementById('sd-content').style.display  = '';

  document.getElementById('tag-session').textContent = 'S/D ANALYSIS';
  const bias = data.bias || {};
  document.getElementById('tag-info').textContent =
    currentTF + ' · bias: ' + (bias.bias||'—') + ' · ' + (data.candidates?.length||0) + ' candidates';

  // Info bar
  const infoBar = document.getElementById('sd-info-bar');
  infoBar.style.display = '';
  infoBar.innerHTML = 'Timeframe: <strong>' + currentTF + '</strong>' +
    ' &nbsp;·&nbsp; Avg body: <strong>' + fmtPrice(data.avg_body) + '</strong>' +
    ' &nbsp;·&nbsp; Looking for: <strong>' + (data.look_for || 'none (bias misaligned)') + '</strong>';

  // Bias block
  const bIcon = b => b==='bullish'?'↑':b==='bearish'?'↓':'⚡';
  const bCls  = b => b==='bullish'?'bullish':b==='bearish'?'bearish':'misaligned';
  document.getElementById('sd-bias-block').innerHTML =
    '<div class="bias-cell">' +
      '<div class="bias-cell-label">Daily</div>' +
      '<div class="bias-cell-val ' + bCls(bias.daily_bias) + '">' + bIcon(bias.daily_bias) + ' ' + (bias.daily_bias||'—') + '</div>' +
      '<div style="font-size:9px;color:var(--muted);margin-top:3px">O ' + fmtPrice(bias.daily_open) + ' → C ' + fmtPrice(bias.daily_close) + '</div>' +
    '</div>' +
    '<div class="bias-cell">' +
      '<div class="bias-cell-label">Weekly</div>' +
      '<div class="bias-cell-val ' + bCls(bias.weekly_bias) + '">' + bIcon(bias.weekly_bias) + ' ' + (bias.weekly_bias||'—') + '</div>' +
      '<div style="font-size:9px;color:var(--muted);margin-top:3px">O ' + fmtPrice(bias.weekly_open) + ' → C ' + fmtPrice(bias.weekly_close) + '</div>' +
    '</div>';

  const verdictEl = document.getElementById('sd-bias-verdict');
  if (bias.bias === 'misaligned') {
    verdictEl.innerHTML = '<div style="padding:6px 10px;background:rgba(240,90,126,0.07);border:1px solid rgba(240,90,126,0.2);border-radius:3px;font-size:10px;color:var(--red);margin-bottom:8px">✗ Bias misaligned — no zones detected</div>';
  } else {
    const col = bias.bias==='bullish'?'var(--pass)':'var(--red)';
    verdictEl.innerHTML = '<div style="padding:6px 10px;background:rgba(90,240,196,0.05);border:1px solid rgba(90,240,196,0.15);border-radius:3px;font-size:10px;color:' + col + ';margin-bottom:8px">✓ Aligned ' + bias.bias + ' — scanning for <strong>' + (data.look_for||'').toUpperCase() + '</strong></div>';
  }

  const candidates = data.candidates || [];
  if (!candidates.length) {
    document.getElementById('sd-zone-list').innerHTML = '<div class="panel-empty">No candidates in scan range</div>';
    return;
  }

  const active   = candidates.filter(c => c.is_active);
  const rejected = candidates.filter(c => !c.is_active);

  document.getElementById('sd-zone-list').innerHTML =
    '<div class="section-header"><span>Active Zones</span><span class="section-count">' + active.length + '</span></div>' +
    active.map((z,i) => renderZoneRow(z, i, true)).join('') +
    '<div class="section-header" style="margin-top:12px"><span>Rejected Candidates</span><span class="section-count">' + rejected.length + '</span></div>' +
    rejected.map((z,i) => renderZoneRow(z, i + 1000, false)).join('');

  // Draw active zones on chart
  clearOverlays();
  active.forEach(z => {
    const col = z.type==='demand' ? 'rgba(90,158,240,0.7)' : 'rgba(240,90,126,0.7)';
    drawBox(z.start, z.end, z.top, z.bottom, col, 0.07);
  });
}

function renderZoneRow(z, idx, isActive) {
  const rowClass  = isActive ? (z.type||'reject') + '-row' : 'rejected-row';
  const badgeCls  = isActive ? (z.type||'reject') : 'reject';
  const badgeTxt  = isActive ? (z.type||'?').toUpperCase() : 'REJECTED';
  const timeStr   = z.start ? fmtTime(z.start) : '—';
  return '<div class="zone-row ' + rowClass + '" id="zone-row-' + idx + '" onclick="selectZone(' + idx + ', ' + isActive + ')">' +
    '<div class="zone-top-row">' +
      '<span class="zone-type-badge ' + badgeCls + '">' + badgeTxt + '</span>' +
      '<span class="zone-time">' + timeStr + '</span>' +
    '</div>' +
    '<div class="zone-range">' + fmtPrice(z.bottom) + ' – ' + fmtPrice(z.top) + '</div>' +
    (z.reject_reason ? '<div class="zone-reject-reason">✗ ' + z.reject_reason + '</div>' : '') +
    (z.session ? '<div style="font-size:9px;color:var(--muted);margin-top:2px">session: ' + z.session + '</div>' : '') +
  '</div>';
}

function scrollToTime(ts) {
  // Scroll the chart so the given timestamp is centred in view.
  // LightweightCharts v4 exposes setVisibleRange on the time scale.
  if (!ts) return;
  const t = shiftTime(ts);
  // Show a window of ±40 candles worth of seconds around the target.
  // We derive the candle interval from the active dataset.
  const src = (currentMode === 'sd' && sdData?.candles)   ? sdData.candles
            : (currentMode === 'fvg' && fvgData?.candles) ? fvgData.candles
            : liveData?.candles;
  let intervalSecs = 60; // default 1m
  if (src && src.length > 1) {
    intervalSecs = src[1].time - src[0].time;
  }
  const window = intervalSecs * 40;
  try {
    chart.timeScale().setVisibleRange({ from: t - window, to: t + window });
  } catch(e) { /* ignore if chart not ready */ }
}

function selectZone(idx, isActive) {
  document.querySelectorAll('.zone-row').forEach(r => r.classList.remove('selected-zone'));
  const el = document.getElementById('zone-row-' + idx);
  if (el) {
    el.classList.add('selected-zone');
    el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }

  if (!sdData?.candidates) return;
  const active   = sdData.candidates.filter(c => c.is_active);
  const rejected = sdData.candidates.filter(c => !c.is_active);
  const z = idx < 1000 ? active[idx] : rejected[idx - 1000];
  if (!z) return;

  clearOverlays();

  // Redraw all active zones dimmed
  active.forEach(az => {
    const col = az.type==='demand' ? 'rgba(90,158,240,0.25)' : 'rgba(240,90,126,0.25)';
    drawBox(az.start, az.end, az.top, az.bottom, col, 0.03);
  });

  // Highlight selected zone — active or rejected both get a box
  const selCol = z.type==='demand' ? 'rgba(90,158,240,0.9)' :
                 z.type==='supply' ? 'rgba(240,90,126,0.9)' :
                                     'rgba(240,196,90,0.7)';
  const endTs = z.end || (z.start + 3600);
  drawBox(z.start, endTs, z.top, z.bottom, selCol, 0.15);

  // Yellow vertical marker on the indecision candle
  if (z.start) drawVLine(z.start, 'rgba(240,196,90,0.6)');
}

// ═════════════════════════════════════════════════════════════════════════════
// ③ FAIR VALUE GAP
// ═════════════════════════════════════════════════════════════════════════════

async function loadFVG() {
  document.getElementById('fvg-loading').textContent = '⟳ Scanning for FVG patterns (' + currentTF + ')…';
  document.getElementById('fvg-loading').style.display = '';
  document.getElementById('fvg-content').style.display = 'none';
  try {
    const res = await fetch('/debug/fvg?interval=' + currentTF);
    fvgData = await res.json();
    if (fvgData.error) {
      document.getElementById('fvg-loading').textContent = '✗ Error: ' + fvgData.error;
      return;
    }
    if (fvgData.candles?.length) renderChart(fvgData.candles);
    renderFVG(fvgData);
  } catch(e) {
    document.getElementById('fvg-loading').textContent = '✗ Fetch failed: ' + e.message;
  }
}

function renderFVG(data) {
  document.getElementById('fvg-loading').style.display = 'none';
  document.getElementById('fvg-content').style.display = '';

  const minGap    = data.min_gap_pct      || 0.0001;
  const impBody   = data.impulse_body_pct || 0.60;

  document.getElementById('tag-session').textContent = 'FVG ANALYSIS';
  document.getElementById('tag-info').textContent =
    currentTF + ' · ' + (data.passed||0) + ' FVGs / ' + (data.total||0) + ' scanned';

  // Info bar
  const infoBar = document.getElementById('fvg-info-bar');
  infoBar.style.display = '';
  infoBar.innerHTML =
    'Min gap: <strong>' + (minGap*100).toFixed(3) + '%</strong>' +
    ' &nbsp;·&nbsp; Min body: <strong>' + (impBody*100).toFixed(0) + '%</strong>' +
    ' &nbsp;·&nbsp; Direction must match impulse';

  // Stats
  document.getElementById('fvg-stats').innerHTML =
    '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:5px">' +
      [
        {l:'Scanned', v:data.total||0,   c:'neutral'},
        {l:'FVG ✓',   v:data.passed||0,  c:(data.passed||0)>0?'green':'red'},
        {l:'Bullish', v:data.bullish||0, c:'neutral'},
        {l:'Bearish', v:data.bearish||0, c:'neutral'},
      ].map(s => '<div class="stat-card"><div class="stat-label">' + s.l + '</div><div class="stat-val sm ' + s.c + '">' + s.v + '</div></div>').join('') +
    '</div>';

  const candidates = data.candidates || [];
  if (!candidates.length) {
    document.getElementById('fvg-list').innerHTML = '<div class="panel-empty">No candidates found</div>';
    return;
  }

  const withFvg    = candidates.filter(c => c.has_fvg);
  const withoutFvg = candidates.filter(c => !c.has_fvg);

  document.getElementById('fvg-list').innerHTML =
    '<div class="section-header" style="margin-top:10px">' +
      '<span>FVG Confirmed</span><span class="section-count">' + withFvg.length + '</span>' +
    '</div>' +
    withFvg.map((c,i) => renderFvgRow(c, i)).join('') +
    '<div class="section-header" style="margin-top:12px">' +
      '<span>Rejected</span><span class="section-count">' + withoutFvg.length + '</span>' +
    '</div>' +
    withoutFvg.slice(0, 40).map((c,i) => renderFvgRow(c, i + 1000)).join('') +
    (withoutFvg.length > 40 ? '<div class="panel-empty" style="font-size:9px">… ' + (withoutFvg.length-40) + ' more</div>' : '');

  // Draw all confirmed FVG gap zones on chart
  clearOverlays();
  withFvg.forEach(c => {
    if (c.gap_top == null) return;
    const col = c.fvg_type==='bullish' ? 'rgba(90,158,240,0.6)' : 'rgba(240,90,126,0.6)';
    const ss = c.candle_nm1?.time || c.candle_n?.time;
    const se = c.candle_np1 ? c.candle_np1.time + 60 : (c.candle_n?.time || 0) + 180;
    if (ss && se) drawBox(ss, se, c.gap_top, c.gap_bottom, col, 0.15);
  });
}

function renderFvgRow(c, idx) {
  const hasFvg   = c.has_fvg;
  const rowCls   = hasFvg ? 'pass-fvg' : 'fail-fvg';
  const badgeCls = c.fvg_type || 'no-fvg';
  const badgeTxt = hasFvg ? (c.fvg_type||'FVG').toUpperCase() : 'NO FVG';
  const timeStr  = c.candle_n?.time ? fmtTime(c.candle_n.time) : '—';
  const impCol   = (c.body_ratio||0) >= 0.6 ? 'var(--pass)' : 'var(--muted)';
  const borderCol = hasFvg
    ? (c.fvg_type==='bullish' ? 'rgba(90,158,240,0.4)' : 'rgba(240,90,126,0.4)')
    : 'var(--border)';

  const gapHtml = hasFvg
    ? '<div class="fvg-gap-line gap-exists">gap: ' + fmtPrice(c.gap_bottom) + ' → ' + fmtPrice(c.gap_top) + ' <span style="color:var(--muted)">(' + ((c.gap_pct||0)*100).toFixed(4) + '%)</span></div>'
    : '<div class="fvg-gap-line gap-missing">✗ ' + (c.reject_reason||'no gap') + '</div>';

  return '<div class="fvg-row ' + rowCls + '" id="fvg-row-' + idx + '" onclick="selectFvg(' + idx + ')">' +
    '<div class="fvg-top-row">' +
      '<span class="fvg-badge ' + badgeCls + '">' + badgeTxt + '</span>' +
      '<span class="zone-time">' + timeStr + '</span>' +
    '</div>' +
    gapHtml +
    '<div class="fvg-detail-grid">' +
      '<div class="fvg-candle-cell">' +
        '<div class="fvg-candle-label">N-1 (prev)</div>' +
        '<div class="fvg-candle-hl">H ' + fmtPrice(c.candle_nm1?.high) + '</div>' +
        '<div class="fvg-candle-hl">L ' + fmtPrice(c.candle_nm1?.low)  + '</div>' +
      '</div>' +
      '<div class="fvg-candle-cell" style="border-color:' + borderCol + '">' +
        '<div class="fvg-candle-label">N (impulse)</div>' +
        '<div class="fvg-candle-hl">H ' + fmtPrice(c.candle_n?.high) + '</div>' +
        '<div class="fvg-candle-hl">L ' + fmtPrice(c.candle_n?.low)  + '</div>' +
        '<div class="fvg-candle-hl" style="color:' + impCol + ';font-size:8px">body ' + ((c.body_ratio||0)*100).toFixed(0) + '%</div>' +
      '</div>' +
      '<div class="fvg-candle-cell">' +
        '<div class="fvg-candle-label">N+1 (after)</div>' +
        '<div class="fvg-candle-hl">H ' + fmtPrice(c.candle_np1?.high) + '</div>' +
        '<div class="fvg-candle-hl">L ' + fmtPrice(c.candle_np1?.low)  + '</div>' +
      '</div>' +
    '</div>' +
  '</div>';
}

function selectFvg(idx) {
  document.querySelectorAll('.fvg-row').forEach(r => r.classList.remove('selected-fvg'));
  const el = document.getElementById('fvg-row-' + idx);
  if (el) {
    el.classList.add('selected-fvg');
    el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }

  if (!fvgData?.candidates) return;
  const withFvg    = fvgData.candidates.filter(c => c.has_fvg);
  const withoutFvg = fvgData.candidates.filter(c => !c.has_fvg);
  const c = idx < 1000 ? withFvg[idx] : withoutFvg[idx - 1000];
  if (!c?.candle_n) return;

  // All confirmed FVG gap zones dimmed
  withFvg.forEach(x => {
    if (!x.gap_top) return;
    const col = x.fvg_type==='bullish' ? 'rgba(90,158,240,0.12)' : 'rgba(240,90,126,0.12)';
    const ss  = x.candle_nm1?.time || x.candle_n.time;
    const se  = x.candle_np1 ? x.candle_np1.time + 60 : x.candle_n.time + 180;
    drawBox(ss, se, x.gap_top, x.gap_bottom, col, 0.04);
  });

  const tn   = c.candle_n.time;
  const tnm1 = c.candle_nm1?.time;
  const tnp1 = c.candle_np1?.time;

  // Mark the 3-candle window
  if (tnm1) drawVLine(tnm1, 'rgba(240,196,90,0.3)');
  drawVLine(tn,  'rgba(240,196,90,0.7)');
  if (tnp1) drawVLine(tnp1, 'rgba(240,196,90,0.3)');

  // Highlight the impulse candle
  const colBright = c.fvg_type==='bullish' ? 'rgba(90,158,240,0.8)'
                  : c.fvg_type==='bearish' ? 'rgba(240,90,126,0.8)'
                  : 'rgba(180,180,180,0.6)';
  drawBox(tn, tn + 60, c.candle_n.high, c.candle_n.low, colBright, 0.12);

  // Draw the FVG gap zone (or show where the gap would be for rejected ones)
  if (c.has_fvg && c.gap_top != null) {
    const gapCol  = c.fvg_type==='bullish' ? 'rgba(90,158,240,0.9)' : 'rgba(240,90,126,0.9)';
    const spanS   = tnm1 || tn - 60;
    const spanE   = tnp1 ? tnp1 + 60 : tn + 180;
    drawBox(spanS, spanE, c.gap_top, c.gap_bottom, gapCol, 0.30);
  } else {
    // For rejected: show the raw wicks of N-1 and N+1 so you can see why there's no gap
    const nm1H = c.candle_nm1?.high, nm1L = c.candle_nm1?.low;
    const np1H = c.candle_np1?.high, np1L = c.candle_np1?.low;
    if (nm1H && tnm1) drawBox(tnm1, tnm1 + 30, nm1H, nm1L, 'rgba(240,196,90,0.5)', 0.08);
    if (np1H && tnp1) drawBox(tnp1, tnp1 + 30, np1H, np1L, 'rgba(240,196,90,0.5)', 0.08);
  }
}

// ── Init ──────────────────────────────────────────────────────────────────────
loadLiveData();
setInterval(() => { if (!replayMode && currentMode === 'accum') loadLiveData(); }, 30000);
</script>
</body>
</html>
