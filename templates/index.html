<!DOCTYPE html>
<html>
<head>
    <title>{{ label }} — Chart Agent</title>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #1e1e1f;
            color: #d1d4dc;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            gap: 12px;
        }
        header {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-shrink: 0;
        }
        header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
        }
        #detector-statuses {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .detector-status {
            display: flex;
            align-items: center;
            gap: 7px;
            background: #1a1d2e;
            border: 1px solid #2b2b43;
            border-radius: 5px;
            padding: 4px 12px;
            font-size: 0.78rem;
            transition: border-color 0.4s, background 0.4s;
        }
        .detector-status .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: background 0.4s;
        }
        .detector-status .label-text { transition: color 0.4s; }

        .detector-status.state-looking { border-color: #2b2b43; }
        .detector-status.state-looking .indicator { background: #444; }
        .detector-status.state-looking .label-text { color: #666; }

        .detector-status.state-potential { border-color: #555; }
        .detector-status.state-potential .indicator {
            background: #aaa;
            box-shadow: 0 0 5px rgba(180,180,180,0.4);
        }
        .detector-status.state-potential .label-text { color: #bbb; }

        .detector-status.state-found { border-color: #888; background: #1e2030; }
        .detector-status.state-found .indicator {
            background: #ccc;
            box-shadow: 0 0 8px rgba(220,220,220,0.6);
        }
        .detector-status.state-found .label-text { color: #e0e0e0; font-weight: 600; }

        .detector-status.state-offline { border-color: #2b2b43; }
        .detector-status.state-offline .indicator { background: #333; }
        .detector-status.state-offline .label-text { color: #444; font-style: italic; }

        /* ── Weekend closed overlay ── */
        #weekend-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 12, 0.88);
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-family: 'Inter', 'Segoe UI', sans-serif;
        }
        #weekend-overlay.visible { display: flex; }
        #weekend-overlay .wk-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #e0e0e0;
            letter-spacing: 0.08em;
        }
        #weekend-overlay .wk-sub {
            font-size: 0.8rem;
            color: #555;
        }
        #weekend-overlay .wk-countdown {
            font-size: 2rem;
            font-weight: 700;
            color: #3a3a5a;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.05em;
        }
        #weekend-overlay .wk-hint {
            font-size: 0.68rem;
            color: #333;
        }
        #interval-bar {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        .tf-btn {
            background: none;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 0.75rem;
            font-family: inherit;
            padding: 3px 9px;
            transition: all 0.2s;
        }
        .tf-btn:hover { border-color: #888; color: #bbb; }
        .tf-btn.active { border-color: #d4d0d0; color: #d4d0d0; font-weight: 600; }

        /* ── Session badge ── */
        #session-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            padding: 3px 10px;
            font-size: 0.75rem;
            color: #666;
            white-space: nowrap;
        }
        #session-badge .session-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: #444;
        }
        #session-badge.inactive { border-color: #444; color: #555; }
        #session-badge.inactive .session-dot { background: #444; }
        #session-badge.asian    { border-color: #c8a84b; color: #c8a84b; }
        #session-badge.asian    .session-dot { background: #c8a84b; box-shadow: 0 0 5px rgba(200,168,75,0.5); }
        #session-badge.london   { border-color: #4b9ecd; color: #4b9ecd; }
        #session-badge.london   .session-dot { background: #4b9ecd; box-shadow: 0 0 5px rgba(75,158,205,0.5); }
        #session-badge.new_york { border-color: #6abf7b; color: #6abf7b; }
        #session-badge.new_york .session-dot { background: #6abf7b; box-shadow: 0 0 5px rgba(106,191,123,0.5); }

        /* ── Bias badge ── */
        #bias-badge {
            display: none;
            align-items: center;
            gap: 6px;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            padding: 3px 10px;
            font-size: 0.75rem;
            color: #666;
            white-space: nowrap;
        }
        #bias-badge .bias-dot {
            width: 7px; height: 7px;
            border-radius: 50%;
            background: #444;
        }
        #bias-badge.bullish  { border-color: #4caf82; color: #4caf82; }
        #bias-badge.bullish  .bias-dot { background: #4caf82; box-shadow: 0 0 5px rgba(76,175,130,0.5); }
        #bias-badge.bearish  { border-color: #cf6679; color: #cf6679; }
        #bias-badge.bearish  .bias-dot { background: #cf6679; box-shadow: 0 0 5px rgba(207,102,121,0.5); }
        #bias-badge.misaligned { border-color: #888; color: #666; }
        #bias-badge.misaligned .bias-dot { background: #555; }

        #chart-container {
            flex: 1;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            overflow: hidden;
        }
        #chart { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <header>
        <h1>{{ label }}</h1>
        <div id="detector-statuses">
            <!-- Status badges injected by JS -->
        </div>
        <div id="session-badge">
            <span class="session-dot"></span>
            <span id="session-label">--</span>
        </div>
        <div id="bias-badge">
            <span class="bias-dot"></span>
            <span id="bias-label">--</span>
        </div>
        <div id="interval-bar">
            <button class="tf-btn active" data-interval="1m">1m</button>
            <button class="tf-btn" data-interval="5m">5m</button>
            <button class="tf-btn" data-interval="15m">15m</button>
            <button class="tf-btn" data-interval="30m">30m</button>
            <button class="tf-btn" data-interval="1h">1h</button>
        </div>
    </header>

    <div id="chart-container">
        <div id="chart"></div>
    </div>

    <!-- Weekend closed overlay -->
    <div id="weekend-overlay">
        <div class="wk-title">⛔ Market Closed</div>
        <div class="wk-sub">Weekend halt — Fri 23:00 UTC to Mon 01:00 UTC</div>
        <div class="wk-countdown" id="wk-countdown">00:00:00</div>
        <div class="wk-hint">Resumes Monday 01:00 UTC (Asian session open)</div>
    </div>

    <script>
        const PAIR_ID = "{{ pair_id }}";
        const TIMEZONE = "{{ timezone }}";

        // ── Timezone offset ───────────────────────────────────────────
        // LightweightCharts 4.x doesn't support timezone config directly.
        // We shift timestamps by the container's UTC offset so the chart
        // displays times in the correct local timezone.
        function getTzOffsetSeconds(tz) {
            try {
                const now = new Date();
                // Get UTC time and local time in the target timezone
                const utcStr = now.toLocaleString('en-US', { timeZone: 'UTC' });
                const tzStr  = now.toLocaleString('en-US', { timeZone: tz });
                const diff   = (new Date(tzStr) - new Date(utcStr)) / 1000;
                return diff;
            } catch(e) {
                return 0;
            }
        }
        const TZ_OFFSET = getTzOffsetSeconds(TIMEZONE);

        function shiftTime(ts) {
            return ts + TZ_OFFSET;
        }
        let currentInterval = "{{ default_interval }}";

        // ── Session clock ─────────────────────────────────────────────
        // Sessions are defined in UTC — same for everyone worldwide.
        // The browser converts UTC start times to local time for the countdown.
        const SESSION_LABELS = {
            asian:    'Asian',
            london:   'London',
            new_york: 'New York',
        };

        // Session windows in UTC hours
        // Asian:    01:00 – 07:00 UTC  (02:00 – 08:00 CET)
        // London:   08:00 – 12:00 UTC  (09:00 – 13:00 CET)
        // New York: 13:00 – 19:00 UTC  (15:00 – 20:00 CET)
        const SESSION_WINDOWS_UTC = [
            { name: 'asian',    start: 1,  end: 7  },
            { name: 'london',   start: 8,  end: 12 },
            { name: 'new_york', start: 13, end: 19 },
        ];

        function getCurrentSession() {
            const hour = new Date().getUTCHours();
            for (const s of SESSION_WINDOWS_UTC) {
                if (hour >= s.start && hour < s.end) return s.name;
            }
            return null;
        }

        function getNextSession() {
            const now     = new Date();
            const utcHour = now.getUTCHours();
            // Find next session start in UTC
            let next = SESSION_WINDOWS_UTC.find(s => s.start > utcHour);
            if (!next) next = SESSION_WINDOWS_UTC[0];  // wrap to tomorrow
            // Build a Date for the next session start in UTC
            const target = new Date(now);
            target.setUTCHours(next.start, 0, 0, 0);
            if (target <= now) target.setUTCDate(target.getUTCDate() + 1);
            const diffMs = target - now;
            const diffH  = Math.floor(diffMs / 3600000);
            const diffM  = Math.floor((diffMs % 3600000) / 60000);
            const diffS  = Math.floor((diffMs % 60000) / 1000);
            const pad    = n => String(n).padStart(2, '0');
            return {
                name:      next.name,
                countdown: `${pad(diffH)}:${pad(diffM)}:${pad(diffS)}`,
            };
        }

        function updateSessionBadge() {
            const session = getCurrentSession();
            const badge   = document.getElementById('session-badge');
            if (session) {
                badge.className = session;
                document.getElementById('session-label').textContent = SESSION_LABELS[session] + ' Session';
            } else {
                const next = getNextSession();
                badge.className = 'inactive';
                document.getElementById('session-label').textContent =
                    SESSION_LABELS[next.name] + ' opens in ' + next.countdown;
            }
        }

        updateSessionBadge();
        setInterval(updateSessionBadge, 1000);

        // ── Interval buttons ─────────────────────────────────────────
        // Activate correct button on page load
        document.querySelectorAll('.tf-btn').forEach(btn => {
            if (btn.dataset.interval === currentInterval) btn.classList.add('active');
            else btn.classList.remove('active');
        });

        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentInterval = btn.dataset.interval;
                loadData();
            });
        });

        // ── Chart Setup ──────────────────────────────────────────────
        const container = document.getElementById('chart');
        const chart = LightweightCharts.createChart(container, {
            layout: { background: { color: '#1e1e1f' }, textColor: '#d1d4dc' },
            grid: { vertLines: { visible: false }, horzLines: { visible: false } },
            timeScale: { timeVisible: true, borderColor: '#2B2B43' },
        });

        const candleSeries = chart.addCandlestickSeries({
            upColor:       '#d4d0d0',
            downColor:     '#068c76',
            wickUpColor:   '#d4d0d0',
            wickDownColor: '#068c76',
            borderVisible: false,
            wickVisible:   true,
        });

        // ── Status Badge helpers ──────────────────────────────────────
        const statusContainer = document.getElementById('detector-statuses');
        const statusEls = {};

        const STATUS_CONFIG = {
            // accumulation
            looking:         { label: 'Looking for accumulation',         css: 'state-looking'   },
            potential:       { label: 'Potential accumulation forming',    css: 'state-potential' },
            found:           { label: 'Accumulation found',                css: 'state-found'     },
            confirmed:       { label: 'Accumulation confirmed — alerting', css: 'state-found'     },
            out_of_session:  { label: 'Out of session',                    css: 'state-offline'   },
            weekend_closed:  { label: 'Market closed — weekend',           css: 'state-offline'   },
            // supply_demand
            sd_found:        { label: 'Supply/Demand zones found',         css: 'state-found'    },
            sd_none:         { label: 'No S/D zones found',                css: 'state-looking'  },
            sd_misaligned:   { label: 'Bias misaligned — not looking',     css: 'state-offline'  },
            sd_bullish:      { label: 'Bias bullish — seeking demand',     css: 'state-found'    },
            sd_bearish:      { label: 'Bias bearish — seeking supply',     css: 'state-found'    },
            sd_weekend:      { label: 'Market closed — weekend',           css: 'state-offline'  },
        };

        // ── Weekend check (client-side) ───────────────────────────────
        function isWeekendHalt() {
            const now = new Date();
            const dow  = now.getUTCDay();   // 0=Sun,1=Mon…5=Sat,6=Sun
            const hour = now.getUTCHours();
            if (dow === 5 && hour >= 23) return true;   // Fri ≥ 23:00
            if (dow === 6) return true;                  // All Saturday
            if (dow === 0 && hour < 1) return true;      // Sun < 01:00
            return false;
        }

        function getWeekendCountdown() {
            // Returns countdown string to Monday 01:00 UTC
            const now = new Date();
            const target = new Date(now);
            // Find next Monday 01:00 UTC
            const dow = now.getUTCDay();
            let daysUntilMon = (1 - dow + 7) % 7;
            if (daysUntilMon === 0) daysUntilMon = 7; // already Monday but halt still active before 01:00
            target.setUTCDate(target.getUTCDate() + daysUntilMon);
            target.setUTCHours(1, 0, 0, 0);
            const diff = target - now;
            const h = Math.floor(diff / 3600000);
            const m = Math.floor((diff % 3600000) / 60000);
            const s = Math.floor((diff % 60000) / 1000);
            const pad = n => String(n).padStart(2, '0');
            return `${pad(h)}:${pad(m)}:${pad(s)}`;
        }

        function ensureStatusEl(detectorName) {
            if (statusEls[detectorName]) return statusEls[detectorName];
            const el = document.createElement('div');
            el.className = 'detector-status state-looking';
            el.innerHTML = `<span class="indicator"></span><span class="label-text"></span>`;
            statusContainer.appendChild(el);
            statusEls[detectorName] = el;
            return el;
        }

        function setStatus(detectorName, state) {
            const el = ensureStatusEl(detectorName);
            const cfg = STATUS_CONFIG[state] || STATUS_CONFIG.looking;
            el.className = `detector-status ${cfg.css}`;
            el.querySelector('.label-text').textContent = cfg.label;
        }

        // ── Detector Overlay Renderers ────────────────────────────────
        const detectorRenderers = {
            accumulation: renderAccumulation,
            supply_demand: renderSupplyDemand,
        };

        const activeSeries = {};

        function renderAccumulation(chart, zone) {
            const isFound = zone.status === 'found' || zone.status === 'confirmed';
            // Don't render if status is looking/potential without valid zone coords
            if (!zone.top || !zone.bottom || !zone.start) return [];

            const allSeries = [];

            // ── Accumulation box: grey OUTLINE only (no fill) ────────────────
            const lineAlpha = isFound ? 0.55 : 0.28;
            const lineColor = `rgba(200, 200, 200, ${lineAlpha})`;
            const lineStyle = isFound ? 0 : 2;
            const seriesOpts = { color: lineColor, lineWidth: 1, lineStyle,
                priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false };

            const topLine = chart.addLineSeries(seriesOpts);
            topLine.setData([
                { time: shiftTime(zone.start), value: zone.top },
                { time: shiftTime(zone.end),   value: zone.top },
            ]);
            const bottomLine = chart.addLineSeries(seriesOpts);
            bottomLine.setData([
                { time: shiftTime(zone.start), value: zone.bottom },
                { time: shiftTime(zone.end),   value: zone.bottom },
            ]);
            const leftLine = chart.addLineSeries(seriesOpts);
            leftLine.setData([
                { time: shiftTime(zone.start), value: zone.top },
                { time: shiftTime(zone.start), value: zone.bottom },
            ]);
            const rightLine = chart.addLineSeries(seriesOpts);
            rightLine.setData([
                { time: shiftTime(zone.end), value: zone.top },
                { time: shiftTime(zone.end), value: zone.bottom },
            ]);
            allSeries.push(topLine, bottomLine, leftLine, rightLine);

            // ── FVG breakout candle zone: filled box (like supply/demand) ───
            const fvg = zone.fvg_candle;
            if (fvg && fvg.top != null && fvg.bottom != null && fvg.time != null) {
                const isBullish = fvg.fvg_type === 'bullish';
                // Use same colors as supply/demand zones
                const fvgColor = isBullish ? 'rgba(70, 130, 220, 0.55)' : 'rgba(220, 100, 50, 0.55)';
                const fvgFill  = isBullish ? 'rgba(70, 130, 220, 0.12)' : 'rgba(220, 100, 50, 0.12)';
                const fvgOpts = { color: fvgColor, lineWidth: 1, lineStyle: 0,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false };

                // Use zone.end as the right edge (current candle) so the box stays visible
                const fvgEnd = shiftTime(zone.end);
                const fvgStart = shiftTime(fvg.time);

                const fTop = chart.addLineSeries(fvgOpts);
                fTop.setData([{ time: fvgStart, value: fvg.top }, { time: fvgEnd, value: fvg.top }]);
                const fBot = chart.addLineSeries(fvgOpts);
                fBot.setData([{ time: fvgStart, value: fvg.bottom }, { time: fvgEnd, value: fvg.bottom }]);
                const fLeft = chart.addLineSeries(fvgOpts);
                fLeft.setData([{ time: fvgStart, value: fvg.top }, { time: fvgStart, value: fvg.bottom }]);
                const fRight = chart.addLineSeries(fvgOpts);
                fRight.setData([{ time: fvgEnd, value: fvg.top }, { time: fvgEnd, value: fvg.bottom }]);
                const fFill = chart.addBaselineSeries({
                    baseValue: { type: 'price', price: fvg.bottom },
                    topFillColor1: fvgFill, topFillColor2: fvgFill,
                    topLineColor: 'rgba(0,0,0,0)',
                    bottomFillColor1: 'rgba(0,0,0,0)', bottomFillColor2: 'rgba(0,0,0,0)',
                    bottomLineColor: 'rgba(0,0,0,0)',
                    lineWidth: 0,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                fFill.setData([{ time: fvgStart, value: fvg.top }, { time: fvgEnd, value: fvg.top }]);
                allSeries.push(fTop, fBot, fLeft, fRight, fFill);
            }

            return allSeries;
        }

        function updateBiasBadge(bias) {
            const badge = document.getElementById('bias-badge');
            const label = document.getElementById('bias-label');
            if (!bias) { badge.style.display = 'none'; return; }
            badge.style.display = 'flex';
            badge.className = bias.bias;
            if (bias.bias === 'bullish') {
                label.textContent = '↑ Bullish Bias (D+W)';
            } else if (bias.bias === 'bearish') {
                label.textContent = '↓ Bearish Bias (D+W)';
            } else {
                label.textContent = '⚡ Bias Misaligned';
            }
        }

        function renderSupplyDemand(chart, result) {
            const allSeries = [];
            // Handle new {bias, zones} structure
            const allZones = Array.isArray(result) ? result : (result && result.zones ? result.zones : []);
            const zones = allZones;
            const bias  = result && result.bias ? result.bias : null;

            updateBiasBadge(bias);

            if (!zones.length) return allSeries;

            // If a highlight param is set (Playwright screenshot mode), dim non-highlighted zones
            const urlParams = new URLSearchParams(window.location.search);
            const highlightTs = urlParams.get('highlight') ? parseInt(urlParams.get('highlight')) : null;

            zones.forEach(zone => {
                const isDemand   = zone.type === 'demand';
                const isHighlighted = !highlightTs || zone.start === highlightTs;

                // Highlighted zone: full opacity. Others: dimmed.
                const color = isDemand
                    ? (isHighlighted ? 'rgba(70, 130, 220, 0.9)' : 'rgba(70, 130, 220, 0.15)')
                    : (isHighlighted ? 'rgba(220, 100, 50, 0.9)'  : 'rgba(220, 100, 50, 0.15)');
                const fill  = isDemand
                    ? (isHighlighted ? 'rgba(70, 130, 220, 0.18)' : 'rgba(70, 130, 220, 0.03)')
                    : (isHighlighted ? 'rgba(220, 100, 50, 0.18)' : 'rgba(220, 100, 50, 0.03)');
                const lineWidth = isHighlighted ? 2 : 1;

                const topLine = chart.addLineSeries({
                    color, lineWidth, lineStyle: 0,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                topLine.setData([{ time: shiftTime(zone.start), value: zone.top }, { time: shiftTime(zone.end), value: zone.top }]);

                const bottomLine = chart.addLineSeries({
                    color, lineWidth, lineStyle: 0,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                bottomLine.setData([{ time: shiftTime(zone.start), value: zone.bottom }, { time: shiftTime(zone.end), value: zone.bottom }]);

                const fillSeries = chart.addBaselineSeries({
                    baseValue: { type: 'price', price: zone.bottom },
                    topFillColor1: fill, topFillColor2: fill,
                    topLineColor: 'rgba(0,0,0,0)',
                    bottomFillColor1: 'rgba(0,0,0,0)', bottomFillColor2: 'rgba(0,0,0,0)',
                    bottomLineColor: 'rgba(0,0,0,0)',
                    lineWidth: 0,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                fillSeries.setData([{ time: shiftTime(zone.start), value: zone.top }, { time: shiftTime(zone.end), value: zone.top }]);

                allSeries.push(topLine, bottomLine, fillSeries);
            });

            return allSeries;
        }

        // ── Data Loop ─────────────────────────────────────────────────
        function checkWeekendOverlay() {
            const overlay = document.getElementById('weekend-overlay');
            if (isWeekendHalt()) {
                overlay.classList.add('visible');
                document.getElementById('wk-countdown').textContent = getWeekendCountdown();
                return true;
            } else {
                overlay.classList.remove('visible');
                return false;
            }
        }

        function loadData() {
            if (checkWeekendOverlay()) return;  // skip fetch during weekend
            fetch(`/api/data?interval=${currentInterval}`)
                .then(res => res.json())
                .then(data => {
                    if (!data.candles) return;

                    const shifted = data.candles.map(c => ({ ...c, time: shiftTime(c.time) }));
                    candleSeries.setData(shifted);

                    for (const [name, seriesList] of Object.entries(activeSeries)) {
                        (seriesList || []).forEach(s => { try { chart.removeSeries(s); } catch(e){} });
                        delete activeSeries[name];
                    }

                    const detectors = data.detectors || {};
                    for (const [name, result] of Object.entries(detectors)) {
                        const renderer = detectorRenderers[name];
                        if (result && renderer) {
                            activeSeries[name] = renderer(chart, result);
                            // Supply/demand returns an array — pick status from first zone
                            if (name === 'supply_demand') {
                                const bias  = result.bias  || {};
                                const zones = result.zones || [];
                                updateBiasBadge(bias);
                                if (bias.bias === 'misaligned') {
                                    setStatus(name, 'sd_misaligned');
                                } else if (zones.length > 0) {
                                    setStatus(name, 'sd_found');
                                } else if (bias.bias === 'bullish') {
                                    setStatus(name, 'sd_bullish');
                                } else if (bias.bias === 'bearish') {
                                    setStatus(name, 'sd_bearish');
                                } else {
                                    setStatus(name, 'sd_none');
                                }
                            } else if (name === 'accumulation') {
                                const s = result.status;
                                if (s === 'weekend') {
                                    setStatus(name, 'weekend_closed');
                                } else if (s === 'confirmed') {
                                    setStatus(name, 'confirmed');
                                } else if (s === 'found' || s === 'potential') {
                                    setStatus(name, s);
                                } else {
                                    setStatus(name, 'looking');
                                }
                            } else {
                                setStatus(name, result.status || (result.is_active ? 'found' : 'looking'));
                            }
                        } else {
                            ensureStatusEl(name);
                            if (name === 'supply_demand') {
                                updateBiasBadge(null);
                                setStatus(name, 'sd_none');
                            } else {
                                // null = truly out of session
                                setStatus(name, 'out_of_session');
                            }
                        }
                    }
                })
                .catch(err => console.error('Fetch error:', err));
        }

        setInterval(() => {
            checkWeekendOverlay();
            if (!isWeekendHalt()) loadData();
        }, 2000);
        checkWeekendOverlay();
        if (!isWeekendHalt()) loadData();

        window.addEventListener('resize', () => chart.applyOptions({ width: container.clientWidth }));
    </script>
</body>
</html>
