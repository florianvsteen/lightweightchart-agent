<!DOCTYPE html>
<html>
<head>
    <title>{{ label }} — Chart Agent</title>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #131722;
            color: #d1d4dc;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            gap: 12px;
        }
        header {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-shrink: 0;
        }
        header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
        }
        #detector-statuses {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .detector-status {
            display: flex;
            align-items: center;
            gap: 7px;
            background: #1a1d2e;
            border: 1px solid #2b2b43;
            border-radius: 5px;
            padding: 4px 12px;
            font-size: 0.78rem;
            transition: border-color 0.4s, background 0.4s;
        }
        .detector-status .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: background 0.4s;
        }
        .detector-status .label-text {
            transition: color 0.4s;
        }

        /* ── States ── */
        .detector-status.state-looking {
            border-color: #2b2b43;
        }
        .detector-status.state-looking .indicator { background: #444; }
        .detector-status.state-looking .label-text { color: #666; }

        .detector-status.state-potential {
            border-color: #555;
        }
        .detector-status.state-potential .indicator {
            background: #aaa;
            box-shadow: 0 0 5px rgba(180,180,180,0.4);
        }
        .detector-status.state-potential .label-text { color: #bbb; }

        .detector-status.state-found {
            border-color: #888;
            background: #1e2030;
        }
        .detector-status.state-found .indicator {
            background: #ccc;
            box-shadow: 0 0 8px rgba(220,220,220,0.6);
        }
        .detector-status.state-found .label-text { color: #e0e0e0; font-weight: 600; }

        #chart-container {
            flex: 1;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            overflow: hidden;
        }
        #chart { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <header>
        <h1>{{ label }}</h1>
        <div id="detector-statuses">
            <!-- Status badges injected by JS -->
        </div>
    </header>

    <div id="chart-container">
        <div id="chart"></div>
    </div>

    <script>
        const PAIR_ID = "{{ pair_id }}";

        // ── Chart Setup ──────────────────────────────────────────────
        const container = document.getElementById('chart');
        const chart = LightweightCharts.createChart(container, {
            layout: { background: { color: '#131722' }, textColor: '#d1d4dc' },
            grid: { vertLines: { color: '#1f222d' }, horzLines: { color: '#1f222d' } },
            timeScale: { timeVisible: true, borderColor: '#2B2B43' },
        });

        const candleSeries = chart.addCandlestickSeries({
            upColor: '#26a69a',
            downColor: '#ef5350',
            borderVisible: false,
            wickVisible: true,
        });

        // ── Status Badge helpers ──────────────────────────────────────
        const statusContainer = document.getElementById('detector-statuses');
        const statusEls = {};

        const STATUS_CONFIG = {
            looking:   { label: 'Looking for accumulation',       css: 'state-looking'   },
            potential: { label: 'Potential accumulation forming',  css: 'state-potential' },
            found:     { label: 'Accumulation found',              css: 'state-found'     },
        };

        function ensureStatusEl(detectorName) {
            if (statusEls[detectorName]) return statusEls[detectorName];
            const el = document.createElement('div');
            el.className = 'detector-status state-looking';
            el.innerHTML = `<span class="indicator"></span><span class="label-text"></span>`;
            statusContainer.appendChild(el);
            statusEls[detectorName] = el;
            return el;
        }

        function setStatus(detectorName, state /* "looking"|"potential"|"found" */) {
            const el = ensureStatusEl(detectorName);
            const cfg = STATUS_CONFIG[state] || STATUS_CONFIG.looking;
            el.className = `detector-status ${cfg.css}`;
            el.querySelector('.label-text').textContent = cfg.label;
        }

        // ── Detector Overlay Renderers ────────────────────────────────
        // Each renderer receives (chart, zone) and returns an array of series.
        const detectorRenderers = {
            accumulation: renderAccumulation,
        };

        const activeSeries = {};  // detectorName → [ series, ... ]

        function renderAccumulation(chart, zone) {
            const isFound    = zone.status === 'found';
            const isPotential = zone.status === 'potential';

            // Colours: found = light grey, potential = dimmer grey
            const lineAlpha  = isFound ? 0.55 : 0.28;
            const fillAlpha  = isFound ? 0.08 : 0.03;
            const lineColor  = `rgba(200, 200, 200, ${lineAlpha})`;
            const fillColor  = `rgba(200, 200, 200, ${fillAlpha})`;

            // Top boundary line
            const topLine = chart.addLineSeries({
                color: lineColor,
                lineWidth: 1,
                lineStyle: isFound ? 0 : 2,   // 0 = solid, 2 = dashed
                priceLineVisible: false,
                lastValueVisible: false,
                crosshairMarkerVisible: false,
            });
            topLine.setData([
                { time: zone.start, value: zone.top },
                { time: zone.end,   value: zone.top },
            ]);

            // Bottom boundary line
            const bottomLine = chart.addLineSeries({
                color: lineColor,
                lineWidth: 1,
                lineStyle: isFound ? 0 : 2,
                priceLineVisible: false,
                lastValueVisible: false,
                crosshairMarkerVisible: false,
            });
            bottomLine.setData([
                { time: zone.start, value: zone.bottom },
                { time: zone.end,   value: zone.bottom },
            ]);

            // Fill — baseline series anchored at bottom, value = top
            const fill = chart.addBaselineSeries({
                baseValue: { type: 'price', price: zone.bottom },
                topFillColor1: fillColor,
                topFillColor2: fillColor,
                topLineColor:  'rgba(0,0,0,0)',
                bottomFillColor1: 'rgba(0,0,0,0)',
                bottomFillColor2: 'rgba(0,0,0,0)',
                bottomLineColor:  'rgba(0,0,0,0)',
                lineWidth: 0,
                priceLineVisible: false,
                lastValueVisible: false,
                crosshairMarkerVisible: false,
            });
            fill.setData([
                { time: zone.start, value: zone.top },
                { time: zone.end,   value: zone.top },
            ]);

            return [topLine, bottomLine, fill];
        }

        // ── Data Loop ─────────────────────────────────────────────────
        function loadData() {
            fetch('/api/data')
                .then(res => res.json())
                .then(data => {
                    if (!data.candles) return;

                    candleSeries.setData(data.candles);

                    // Remove all previous detector overlays
                    for (const [name, seriesList] of Object.entries(activeSeries)) {
                        (seriesList || []).forEach(s => { try { chart.removeSeries(s); } catch(e){} });
                        delete activeSeries[name];
                    }

                    const detectors = data.detectors || {};
                    for (const [name, result] of Object.entries(detectors)) {
                        const renderer = detectorRenderers[name];
                        if (result && renderer) {
                            activeSeries[name] = renderer(chart, result);
                            setStatus(name, result.status || (result.is_active ? 'found' : 'looking'));
                        } else {
                            ensureStatusEl(name);
                            setStatus(name, 'looking');
                        }
                    }
                })
                .catch(err => console.error('Fetch error:', err));
        }

        setInterval(loadData, 2000);
        loadData();

        window.addEventListener('resize', () => chart.applyOptions({ width: container.clientWidth }));
    </script>
</body>
</html>
