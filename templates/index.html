<!DOCTYPE html>
<html>
<head>
    <title>{{ label }} — Chart Agent</title>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #1e1e1f;
            color: #d1d4dc;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            gap: 12px;
        }
        header {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-shrink: 0;
        }
        header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
        }
        #detector-statuses {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .detector-status {
            display: flex;
            align-items: center;
            gap: 7px;
            background: #1a1d2e;
            border: 1px solid #2b2b43;
            border-radius: 5px;
            padding: 4px 12px;
            font-size: 0.78rem;
            transition: border-color 0.4s, background 0.4s;
        }
        .detector-status .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: background 0.4s;
        }
        .detector-status .label-text { transition: color 0.4s; }

        .detector-status.state-looking { border-color: #2b2b43; }
        .detector-status.state-looking .indicator { background: #444; }
        .detector-status.state-looking .label-text { color: #666; }

        .detector-status.state-potential { border-color: #555; }
        .detector-status.state-potential .indicator {
            background: #aaa;
            box-shadow: 0 0 5px rgba(180,180,180,0.4);
        }
        .detector-status.state-potential .label-text { color: #bbb; }

        .detector-status.state-found { border-color: #888; background: #1e2030; }
        .detector-status.state-found .indicator {
            background: #ccc;
            box-shadow: 0 0 8px rgba(220,220,220,0.6);
        }
        .detector-status.state-found .label-text { color: #e0e0e0; font-weight: 600; }

        /* ── Interval buttons ── */
        #interval-bar {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        .tf-btn {
            background: none;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 0.75rem;
            font-family: inherit;
            padding: 3px 9px;
            transition: all 0.2s;
        }
        .tf-btn:hover { border-color: #888; color: #bbb; }
        .tf-btn.active { border-color: #d4d0d0; color: #d4d0d0; font-weight: 600; }

        #chart-container {
            flex: 1;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            overflow: hidden;
        }
        #chart { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <header>
        <h1>{{ label }}</h1>
        <div id="detector-statuses">
            <!-- Status badges injected by JS -->
        </div>
        <div id="interval-bar">
            <button class="tf-btn active" data-interval="1m">1m</button>
            <button class="tf-btn" data-interval="5m">5m</button>
            <button class="tf-btn" data-interval="15m">15m</button>
            <button class="tf-btn" data-interval="30m">30m</button>
            <button class="tf-btn" data-interval="1h">1h</button>
        </div>
    </header>

    <div id="chart-container">
        <div id="chart"></div>
    </div>

    <script>
        const PAIR_ID = "{{ pair_id }}";
        let currentInterval = "1m";

        // ── Interval buttons ─────────────────────────────────────────
        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentInterval = btn.dataset.interval;
                loadData();
            });
        });

        // ── Chart Setup ──────────────────────────────────────────────
        const container = document.getElementById('chart');
        const chart = LightweightCharts.createChart(container, {
            layout: { background: { color: '#1e1e1f' }, textColor: '#d1d4dc' },
            grid: { vertLines: { visible: false }, horzLines: { visible: false } },
            timeScale: { timeVisible: true, borderColor: '#2B2B43' },
        });

        const candleSeries = chart.addCandlestickSeries({
            upColor:       '#d4d0d0',
            downColor:     '#068c76',
            wickUpColor:   '#d4d0d0',
            wickDownColor: '#068c76',
            borderVisible: false,
            wickVisible:   true,
        });

        // ── Status Badge helpers ──────────────────────────────────────
        const statusContainer = document.getElementById('detector-statuses');
        const statusEls = {};

        const STATUS_CONFIG = {
            // accumulation
            looking:   { label: 'Looking for accumulation',      css: 'state-looking'   },
            potential: { label: 'Potential accumulation forming', css: 'state-potential' },
            found:     { label: 'Accumulation found',             css: 'state-found'     },
            // supply_demand
            sd_found:  { label: 'Supply/Demand zones found',     css: 'state-found'     },
            sd_none:   { label: 'No S/D zones found',            css: 'state-looking'   },
        };

        function ensureStatusEl(detectorName) {
            if (statusEls[detectorName]) return statusEls[detectorName];
            const el = document.createElement('div');
            el.className = 'detector-status state-looking';
            el.innerHTML = `<span class="indicator"></span><span class="label-text"></span>`;
            statusContainer.appendChild(el);
            statusEls[detectorName] = el;
            return el;
        }

        function setStatus(detectorName, state) {
            const el = ensureStatusEl(detectorName);
            const cfg = STATUS_CONFIG[state] || STATUS_CONFIG.looking;
            el.className = `detector-status ${cfg.css}`;
            el.querySelector('.label-text').textContent = cfg.label;
        }

        // ── Detector Overlay Renderers ────────────────────────────────
        const detectorRenderers = {
            accumulation: renderAccumulation,
            supply_demand: renderSupplyDemand,
        };

        const activeSeries = {};

        function renderAccumulation(chart, zone) {
            const isFound   = zone.status === 'found';
            const lineAlpha = isFound ? 0.55 : 0.28;
            const fillAlpha = isFound ? 0.08 : 0.03;
            const lineColor = `rgba(200, 200, 200, ${lineAlpha})`;
            const fillColor = `rgba(200, 200, 200, ${fillAlpha})`;

            const topLine = chart.addLineSeries({
                color: lineColor, lineWidth: 1, lineStyle: isFound ? 0 : 2,
                priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
            });
            topLine.setData([
                { time: zone.start, value: zone.top },
                { time: zone.end,   value: zone.top },
            ]);

            const bottomLine = chart.addLineSeries({
                color: lineColor, lineWidth: 1, lineStyle: isFound ? 0 : 2,
                priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
            });
            bottomLine.setData([
                { time: zone.start, value: zone.bottom },
                { time: zone.end,   value: zone.bottom },
            ]);

            const fill = chart.addBaselineSeries({
                baseValue: { type: 'price', price: zone.bottom },
                topFillColor1: fillColor, topFillColor2: fillColor,
                topLineColor: 'rgba(0,0,0,0)',
                bottomFillColor1: 'rgba(0,0,0,0)', bottomFillColor2: 'rgba(0,0,0,0)',
                bottomLineColor: 'rgba(0,0,0,0)',
                lineWidth: 0,
                priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
            });
            fill.setData([
                { time: zone.start, value: zone.top },
                { time: zone.end,   value: zone.top },
            ]);

            return [topLine, bottomLine, fill];
        }

        function renderSupplyDemand(chart, zones) {
            const allSeries = [];
            if (!Array.isArray(zones)) return allSeries;

            zones.forEach(zone => {
                const isDemand  = zone.type === 'demand';
                const isBroken  = zone.status === 'broken';
                const alpha     = isBroken ? 0.15 : 0.35;
                const fillAlpha = isBroken ? 0.03 : 0.07;
                const color     = isDemand
                    ? `rgba(70, 130, 220, ${alpha})`
                    : `rgba(220, 100, 50, ${alpha})`;
                const fill      = isDemand
                    ? `rgba(70, 130, 220, ${fillAlpha})`
                    : `rgba(220, 100, 50, ${fillAlpha})`;
                const lineStyle = isBroken ? 2 : 0;

                const topLine = chart.addLineSeries({
                    color, lineWidth: 1, lineStyle,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                topLine.setData([{ time: zone.start, value: zone.top }, { time: zone.end, value: zone.top }]);

                const bottomLine = chart.addLineSeries({
                    color, lineWidth: 1, lineStyle,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                bottomLine.setData([{ time: zone.start, value: zone.bottom }, { time: zone.end, value: zone.bottom }]);

                const fillSeries = chart.addBaselineSeries({
                    baseValue: { type: 'price', price: zone.bottom },
                    topFillColor1: fill, topFillColor2: fill,
                    topLineColor: 'rgba(0,0,0,0)',
                    bottomFillColor1: 'rgba(0,0,0,0)', bottomFillColor2: 'rgba(0,0,0,0)',
                    bottomLineColor: 'rgba(0,0,0,0)',
                    lineWidth: 0,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                fillSeries.setData([{ time: zone.start, value: zone.top }, { time: zone.end, value: zone.top }]);

                allSeries.push(topLine, bottomLine, fillSeries);
            });

            return allSeries;
        }

        // ── Data Loop ─────────────────────────────────────────────────
        function loadData() {
            fetch(`/api/data?interval=${currentInterval}`)
                .then(res => res.json())
                .then(data => {
                    if (!data.candles) return;

                    candleSeries.setData(data.candles);

                    for (const [name, seriesList] of Object.entries(activeSeries)) {
                        (seriesList || []).forEach(s => { try { chart.removeSeries(s); } catch(e){} });
                        delete activeSeries[name];
                    }

                    const detectors = data.detectors || {};
                    for (const [name, result] of Object.entries(detectors)) {
                        const renderer = detectorRenderers[name];
                        if (result && renderer) {
                            activeSeries[name] = renderer(chart, result);
                            // Supply/demand returns an array — pick status from first zone
                            if (Array.isArray(result)) {
                                const active = result.filter(z => z.status !== 'broken');
                                setStatus(name, active.length > 0 ? 'sd_found' : 'sd_none');
                            } else {
                                setStatus(name, result.status || (result.is_active ? 'found' : 'looking'));
                            }
                        } else {
                            ensureStatusEl(name);
                            setStatus(name, Array.isArray(result) ? 'sd_none' : 'looking');
                        }
                    }
                })
                .catch(err => console.error('Fetch error:', err));
        }

        setInterval(loadData, 2000);
        loadData();

        window.addEventListener('resize', () => chart.applyOptions({ width: container.clientWidth }));
    </script>
</body>
</html>
