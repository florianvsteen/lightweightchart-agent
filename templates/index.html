<!DOCTYPE html>
<html>
<head>
    <title>{{ label }} — Chart Agent</title>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #1e1e1f;
            color: #d1d4dc;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            gap: 12px;
        }
        header {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-shrink: 0;
        }
        header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
        }
        #detector-statuses {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .detector-status {
            display: flex;
            align-items: center;
            gap: 7px;
            background: #1a1d2e;
            border: 1px solid #2b2b43;
            border-radius: 5px;
            padding: 4px 12px;
            font-size: 0.78rem;
            transition: border-color 0.4s, background 0.4s;
        }
        .detector-status .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: background 0.4s;
        }
        .detector-status .label-text { transition: color 0.4s; }

        .detector-status.state-looking { border-color: #2b2b43; }
        .detector-status.state-looking .indicator { background: #444; }
        .detector-status.state-looking .label-text { color: #666; }

        .detector-status.state-potential { border-color: #555; }
        .detector-status.state-potential .indicator {
            background: #aaa;
            box-shadow: 0 0 5px rgba(180,180,180,0.4);
        }
        .detector-status.state-potential .label-text { color: #bbb; }

        .detector-status.state-found { border-color: #888; background: #1e2030; }
        .detector-status.state-found .indicator {
            background: #ccc;
            box-shadow: 0 0 8px rgba(220,220,220,0.6);
        }
        .detector-status.state-found .label-text { color: #e0e0e0; font-weight: 600; }

        /* ── Interval buttons ── */
        #interval-bar {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        .tf-btn {
            background: none;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 0.75rem;
            font-family: inherit;
            padding: 3px 9px;
            transition: all 0.2s;
        }
        .tf-btn:hover { border-color: #888; color: #bbb; }
        .tf-btn.active { border-color: #d4d0d0; color: #d4d0d0; font-weight: 600; }

        /* ── Session badge ── */
        #session-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            padding: 3px 10px;
            font-size: 0.75rem;
            color: #666;
            white-space: nowrap;
        }
        #session-badge .session-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: #444;
        }
        #session-badge.inactive { border-color: #444; color: #555; }
        #session-badge.inactive .session-dot { background: #444; }
        #session-badge.asian    { border-color: #c8a84b; color: #c8a84b; }
        #session-badge.asian    .session-dot { background: #c8a84b; box-shadow: 0 0 5px rgba(200,168,75,0.5); }
        #session-badge.london   { border-color: #4b9ecd; color: #4b9ecd; }
        #session-badge.london   .session-dot { background: #4b9ecd; box-shadow: 0 0 5px rgba(75,158,205,0.5); }
        #session-badge.new_york { border-color: #6abf7b; color: #6abf7b; }
        #session-badge.new_york .session-dot { background: #6abf7b; box-shadow: 0 0 5px rgba(106,191,123,0.5); }

        #chart-container {
            flex: 1;
            border: 1px solid #2b2b43;
            border-radius: 4px;
            overflow: hidden;
        }
        #chart { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <header>
        <h1>{{ label }}</h1>
        <div id="detector-statuses">
            <!-- Status badges injected by JS -->
        </div>
        <div id="session-badge">
            <span class="session-dot"></span>
            <span id="session-label">--</span>
        </div>
        <div id="interval-bar">
            <button class="tf-btn active" data-interval="1m">1m</button>
            <button class="tf-btn" data-interval="5m">5m</button>
            <button class="tf-btn" data-interval="15m">15m</button>
            <button class="tf-btn" data-interval="30m">30m</button>
            <button class="tf-btn" data-interval="1h">1h</button>
        </div>
    </header>

    <div id="chart-container">
        <div id="chart"></div>
    </div>

    <script>
        const PAIR_ID = "{{ pair_id }}";
        const TIMEZONE = "{{ timezone }}";

        // ── Timezone offset ───────────────────────────────────────────
        // LightweightCharts 4.x doesn't support timezone config directly.
        // We shift timestamps by the container's UTC offset so the chart
        // displays times in the correct local timezone.
        function getTzOffsetSeconds(tz) {
            try {
                const now = new Date();
                // Get UTC time and local time in the target timezone
                const utcStr = now.toLocaleString('en-US', { timeZone: 'UTC' });
                const tzStr  = now.toLocaleString('en-US', { timeZone: tz });
                const diff   = (new Date(tzStr) - new Date(utcStr)) / 1000;
                return diff;
            } catch(e) {
                return 0;
            }
        }
        const TZ_OFFSET = getTzOffsetSeconds(TIMEZONE);

        function shiftTime(ts) {
            return ts + TZ_OFFSET;
        }
        let currentInterval = "{{ default_interval }}";

        // ── Session clock ─────────────────────────────────────────────
        const SESSION_LABELS = {
            asian:    'Asian',
            london:   'London',
            new_york: 'New York',
        };

        // Session hours in CET (browser local time)
        // Asian:    02:00 – 08:00 CET
        // London:   09:00 – 13:00 CET
        // New York: 15:00 – 20:00 CET
        // Outside these windows: show countdown to next session

        const SESSION_WINDOWS = {
            asian:    { start: 2,  end: 8  },
            london:   { start: 9,  end: 13 },
            new_york: { start: 15, end: 20 },
        };

        function getCurrentSession() {
            const hour = new Date().getHours();  // CET local time
            if (hour >= 15 && hour < 20) return 'new_york';
            if (hour >= 9  && hour < 13) return 'london';
            if (hour >= 2  && hour < 8)  return 'asian';
            return null;  // between sessions
        }

        function getNextSession() {
            const now  = new Date();
            const hour = now.getHours();
            // Find the next session start in CET
            const starts = [
                { name: 'asian',    hour: 2  },
                { name: 'london',   hour: 9  },
                { name: 'new_york', hour: 15 },
            ];
            // Find next session that hasn't started yet today, or first of tomorrow
            let next = starts.find(s => s.hour > hour);
            if (!next) next = starts[0];  // wrap to tomorrow
            const target = new Date(now);
            target.setHours(next.hour, 0, 0, 0);
            if (target <= now) target.setDate(target.getDate() + 1);
            const diffMs   = target - now;
            const diffH    = Math.floor(diffMs / 3600000);
            const diffM    = Math.floor((diffMs % 3600000) / 60000);
            const diffS    = Math.floor((diffMs % 60000) / 1000);
            const pad      = n => String(n).padStart(2, '0');
            return {
                name:      next.name,
                countdown: `${pad(diffH)}:${pad(diffM)}:${pad(diffS)}`,
            };
        }

        function updateSessionBadge() {
            const session = getCurrentSession();
            const badge   = document.getElementById('session-badge');
            if (session) {
                badge.className = session;
                document.getElementById('session-label').textContent = SESSION_LABELS[session] + ' Session';
            } else {
                const next = getNextSession();
                badge.className = 'inactive';
                document.getElementById('session-label').textContent =
                    SESSION_LABELS[next.name] + ' opens in ' + next.countdown;
            }
        }

        updateSessionBadge();
        setInterval(updateSessionBadge, 1000);  // update every second for countdown

        // ── Interval buttons ─────────────────────────────────────────
        // Activate correct button on page load
        document.querySelectorAll('.tf-btn').forEach(btn => {
            if (btn.dataset.interval === currentInterval) btn.classList.add('active');
            else btn.classList.remove('active');
        });

        document.querySelectorAll('.tf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentInterval = btn.dataset.interval;
                loadData();
            });
        });

        // ── Chart Setup ──────────────────────────────────────────────
        const container = document.getElementById('chart');
        const chart = LightweightCharts.createChart(container, {
            layout: { background: { color: '#1e1e1f' }, textColor: '#d1d4dc' },
            grid: { vertLines: { visible: false }, horzLines: { visible: false } },
            timeScale: { timeVisible: true, borderColor: '#2B2B43' },
        });

        const candleSeries = chart.addCandlestickSeries({
            upColor:       '#d4d0d0',
            downColor:     '#068c76',
            wickUpColor:   '#d4d0d0',
            wickDownColor: '#068c76',
            borderVisible: false,
            wickVisible:   true,
        });

        // ── Status Badge helpers ──────────────────────────────────────
        const statusContainer = document.getElementById('detector-statuses');
        const statusEls = {};

        const STATUS_CONFIG = {
            // accumulation
            looking:   { label: 'Looking for accumulation',      css: 'state-looking'   },
            potential: { label: 'Potential accumulation forming', css: 'state-potential' },
            found:     { label: 'Accumulation found',             css: 'state-found'     },
            // supply_demand
            sd_found:  { label: 'Supply/Demand zones found',     css: 'state-found'     },
            sd_none:   { label: 'No S/D zones found',            css: 'state-looking'   },
        };

        function ensureStatusEl(detectorName) {
            if (statusEls[detectorName]) return statusEls[detectorName];
            const el = document.createElement('div');
            el.className = 'detector-status state-looking';
            el.innerHTML = `<span class="indicator"></span><span class="label-text"></span>`;
            statusContainer.appendChild(el);
            statusEls[detectorName] = el;
            return el;
        }

        function setStatus(detectorName, state) {
            const el = ensureStatusEl(detectorName);
            const cfg = STATUS_CONFIG[state] || STATUS_CONFIG.looking;
            el.className = `detector-status ${cfg.css}`;
            el.querySelector('.label-text').textContent = cfg.label;
        }

        // ── Detector Overlay Renderers ────────────────────────────────
        const detectorRenderers = {
            accumulation: renderAccumulation,
            supply_demand: renderSupplyDemand,
        };

        const activeSeries = {};

        function renderAccumulation(chart, zone) {
            const isFound   = zone.status === 'found';
            const lineAlpha = isFound ? 0.55 : 0.28;
            const fillAlpha = isFound ? 0.08 : 0.03;
            const lineColor = `rgba(200, 200, 200, ${lineAlpha})`;
            const fillColor = `rgba(200, 200, 200, ${fillAlpha})`;

            const topLine = chart.addLineSeries({
                color: lineColor, lineWidth: 1, lineStyle: isFound ? 0 : 2,
                priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
            });
            topLine.setData([
                { time: shiftTime(zone.start), value: zone.top },
                { time: shiftTime(zone.end),   value: zone.top },
            ]);

            const bottomLine = chart.addLineSeries({
                color: lineColor, lineWidth: 1, lineStyle: isFound ? 0 : 2,
                priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
            });
            bottomLine.setData([
                { time: shiftTime(zone.start), value: zone.bottom },
                { time: shiftTime(zone.end),   value: zone.bottom },
            ]);

            const fill = chart.addBaselineSeries({
                baseValue: { type: 'price', price: zone.bottom },
                topFillColor1: fillColor, topFillColor2: fillColor,
                topLineColor: 'rgba(0,0,0,0)',
                bottomFillColor1: 'rgba(0,0,0,0)', bottomFillColor2: 'rgba(0,0,0,0)',
                bottomLineColor: 'rgba(0,0,0,0)',
                lineWidth: 0,
                priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
            });
            fill.setData([
                { time: shiftTime(zone.start), value: zone.top },
                { time: shiftTime(zone.end),   value: zone.top },
            ]);

            return [topLine, bottomLine, fill];
        }

        function renderSupplyDemand(chart, zones) {
            const allSeries = [];
            if (!Array.isArray(zones)) return allSeries;

            zones.forEach(zone => {
                const isDemand  = zone.type === 'demand';
                const isBroken  = zone.status === 'broken';
                const alpha     = isBroken ? 0.15 : 0.35;
                const fillAlpha = isBroken ? 0.03 : 0.07;
                const color     = isDemand
                    ? `rgba(70, 130, 220, ${alpha})`
                    : `rgba(220, 100, 50, ${alpha})`;
                const fill      = isDemand
                    ? `rgba(70, 130, 220, ${fillAlpha})`
                    : `rgba(220, 100, 50, ${fillAlpha})`;
                const lineStyle = isBroken ? 2 : 0;

                const topLine = chart.addLineSeries({
                    color, lineWidth: 1, lineStyle,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                topLine.setData([{ time: shiftTime(zone.start), value: zone.top }, { time: shiftTime(zone.end), value: zone.top }]);

                const bottomLine = chart.addLineSeries({
                    color, lineWidth: 1, lineStyle,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                bottomLine.setData([{ time: shiftTime(zone.start), value: zone.bottom }, { time: shiftTime(zone.end), value: zone.bottom }]);

                const fillSeries = chart.addBaselineSeries({
                    baseValue: { type: 'price', price: zone.bottom },
                    topFillColor1: fill, topFillColor2: fill,
                    topLineColor: 'rgba(0,0,0,0)',
                    bottomFillColor1: 'rgba(0,0,0,0)', bottomFillColor2: 'rgba(0,0,0,0)',
                    bottomLineColor: 'rgba(0,0,0,0)',
                    lineWidth: 0,
                    priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false,
                });
                fillSeries.setData([{ time: shiftTime(zone.start), value: zone.top }, { time: shiftTime(zone.end), value: zone.top }]);

                allSeries.push(topLine, bottomLine, fillSeries);
            });

            return allSeries;
        }

        // ── Data Loop ─────────────────────────────────────────────────
        function loadData() {
            fetch(`/api/data?interval=${currentInterval}`)
                .then(res => res.json())
                .then(data => {
                    if (!data.candles) return;

                    const shifted = data.candles.map(c => ({ ...c, time: shiftTime(c.time) }));
                    candleSeries.setData(shifted);

                    for (const [name, seriesList] of Object.entries(activeSeries)) {
                        (seriesList || []).forEach(s => { try { chart.removeSeries(s); } catch(e){} });
                        delete activeSeries[name];
                    }

                    const detectors = data.detectors || {};
                    for (const [name, result] of Object.entries(detectors)) {
                        const renderer = detectorRenderers[name];
                        if (result && renderer) {
                            activeSeries[name] = renderer(chart, result);
                            // Supply/demand returns an array — pick status from first zone
                            if (Array.isArray(result)) {
                                const active = result.filter(z => z.status !== 'broken');
                                setStatus(name, active.length > 0 ? 'sd_found' : 'sd_none');
                            } else {
                                setStatus(name, result.status || (result.is_active ? 'found' : 'looking'));
                            }
                        } else {
                            ensureStatusEl(name);
                            setStatus(name, Array.isArray(result) ? 'sd_none' : 'looking');
                        }
                    }
                })
                .catch(err => console.error('Fetch error:', err));
        }

        setInterval(loadData, 2000);
        loadData();

        window.addEventListener('resize', () => chart.applyOptions({ width: container.clientWidth }));
    </script>
</body>
</html>
